import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,b as e,t as c,e as t,n as g,g as l,a as n,r as o,o as m}from"./app-BgNevrm5.js";const d={},u={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},p={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},f=e("nav",{class:"table-of-contents"},[e("ul")],-1),b=e("hr",null,null,-1);function y(a,w){const i=o("VPCard"),s=o("SiteInfo");return m(),h("div",null,[e("h1",u,[e("a",p,[e("span",null,c(a.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),t(i,g(l({title:"Gitting Things Done ‚Äì A Visual and Practical Guide to Git [Full Book]",desc:"Introduction Git is awesome. Most software developers use Git on a daily basis. But how many truly understand Git? Do you feel like you know what's going on under the hood as you use Git to perform various tasks? For example, what happens when you us...",link:"/freecodecamp.org/gitting-things-done-book/README.md",logo:"https://cdn.freecodecamp.org/universal/favicons/favicon.ico",background:"rgba(10,10,35,0.2)"})),null,16),f,b,t(s,{name:"Gitting Things Done ‚Äì A Visual and Practical Guide to Git [Full Book]",desc:"Introduction Git is awesome. Most software developers use Git on a daily basis. But how many truly understand Git? Do you feel like you know what's going on under the hood as you use Git to perform various tasks? For example, what happens when you us...",url:"https://freecodecamp.org/news/gitting-things-done-book/",logo:"https://cdn.freecodecamp.org/universal/favicons/favicon.ico",preview:"https://freecodecamp.org/news/content/images/size/w2000/2023/12/Gitting-Things-Done-Cover-with-Photo.png"}),n(" TODO: ÏûëÏÑ± "),n('\n## ---\n\n## heading-chapter-12-git-log">Chapter 12 - Git Log\n\nYou used `git log` many times across different chapters, and you had probably used it many times before reading this book.\n\nMost developers use `git log`, few use it effectively. In this chapter you will learn useful tweaks for making the most of `git log`. Once you feel comfortable with the different switches of this command, it will be a game changer in your day to day work with Git.\n\nThinking about it, `git log` encompasses the essence of every version control system - that is, to record changes in versions. You record versions so that you can consider the history of your project - perhaps revert or apply specific changes, prefer to switch to a different point in time and test things there. Perhaps you would like to know who contributed a certain piece of code or when they did that.\n\nWhile `git` does preserve this information by using commit objects, that also point to their parent commits, and references to commit objects (such as branches or `HEAD`), this storing of versions is not enough. Without being able to find the relevant commit you would like to consider, or gather the relevant information about it, having this data stored is pretty useless.\n\nYou can think of your commit objects as different books that pile up in a huge stack, or in a library, filling long shelves. The information you might need is in these books, but if you don\'t have an index - a way to know in which book the information you seek lies, or where this book is located within the library - you wouldn\'t be able to make much use of it. `git log` is this indexing of your library - it\'s a way to find the relevant commits and the information about them.\n\nThe useful arguments for `git log` that you will learn in this chapter either format how commits are displayed in the log, or filter specific commits.\n\n`git lol`, an alias which I have used throughout the book, uses some of these switches, as I will demonstrate. Feel free to tweak this alias (or create another from scratch) after reading this chapter.\n\nAs in other chapters, the goal is not to provide a complete reference, therefore I will not provide *all* different switches of `git log`. I will focus on the switches I believe you will find useful.\n\n### heading-filtering-commits">Filtering Commits\n\nConsider the default output of `git log`:\n\n![The output of `git log` without additional switches](https://freecodecamp.org/news/content/images/2023/12/git_log_1.png)\n\nThe log starts from `HEAD`, and follows the parent chain.\n\n<h4 id="heading-commits-not-reachable-from">Commits (Not) Reachable From...\n\nWhen you write `git log <revision>`, `git log` will include all entries reachable from `<revision>`. By "reachable", I refer to reachable by following the parent chain. So running `git log` without any arguments is equivalent to running `git log HEAD`.\n\nYou can specify multiple revisions for `git log` - if you write `git log branch_1 branch_2`, you ask `git log` to include every commit that is reachable from `branch_1` or `branch_2` (or both).\n\n`git log` will **exclude** any commits that are reachable from revisions preceded by a `^`.\n\nFor example, the following command:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log branch_1 ^branch_2\n```\n\nasks `git log` to include every commit that is reachable from `branch_1`, but not those reachable from `branch_2`.\n\nConsider the history when I use `git log feature_branch_1` on this repo:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_2-1.png)Image" width="937" height="854" loading="lazy">\n_`git log feature_branch_1`_\n\nThe history includes all commits reachable by `feature_branch_1`. Since this branch "branched off" `main` (that is, "Commit 12", which `main` points to, is reachable from the parent chain) - the log also includes the commits reachable from `main`.\n\nWhat would happen if I ran this command?\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log feature_branch_1 ^main\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_3.png)Image" width="952" height="325" loading="lazy">\n_`git log feature_branch_1 ^main`_\n\nIndeed, `git log` outputs only "Commit 13" and "Commit 16", which are reachable from `feature_branch_1` but not from `main`.\n\n<h4 id="heading-git-log-all">`git log --all`\n\nTo follow commits that are reachable from any named reference or (any refs in `refs/`) or `HEAD`.\n\n<h4 id="heading-by-author">By Author\n\nIf you know you are looking for a commit that a specific person has authored, you can filter these commits by using that user\'s name or email, like so:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --author="Name"\n```\n\nYou can use regular expressions to look for author names that match a specific pattern, for example:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --author="John\\|Jane"\n```\n\nwill filter commits authored by either John or Jane.\n\n<h4 id="heading-by-date">By Date\n\nWhen you know that the change you are looking for has been committed within a specific timeframe, you can use `--before` or `--after` to filter commits from that timeframe.\n\nFor example, to get all commits introduced after April 12th, 2023 (inclusive), use:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --after="2023-04-12"\n```\n\n<h4 id="heading-by-paths">By Paths\n\nYou can ask `git log` to only show commits where *changes* to files in specific paths have been introduced. Notice that this does not mean any commit that points to a tree that includes the files in question, but rather that if we compute the difference between the commit in question and its parent, we would see that at least one of the paths has been modified.\n\nFor example, you can use:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --all -- 1.py\n```\n\nto find all commits that are reachable from any named pointer, or `HEAD`, and introduce a change to `1.py`. You can specify multiple paths:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --all -- 1.py 2.py\n```\n\nThe previous command will make `git log` include reachable commits that introduced a change to `1.py` or `2.py` (or both).\n\nYou can also use a glob pattern, for example:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log -- *.py\n```\n\nwill include commits reachable from `HEAD` that include a change to any file in the root directory whose name ends with a `.py`. To look for any file whose name ends with `.py`, you can use:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log -- **/*.py\n```\n\n<h4 id="heading-by-commit-message">By Commit Message\n\nIf you know the commit message (or parts of it) of the commit you are searching, you can use the `--grep` switch for "git log", for example:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --grep="Commit 12"\n```\n\nyields back the commit with the message "Commit 12".\n\n<h4 id="heading-by-diff-content">By Diff Content\n\nThis one is super useful, and it saved me countless times. By using `git log -S`, you can search for commits that introduce or remove a particular line of source code. \n\nThis comes in handy, for example, when you know you have created something in the repo, but you don\'t know where it is now. You can\'t find it anywhere on your filesystem (it\'s not in `HEAD`), and you know it must be there - lurking somewhere in this library (bunch of commits) that you have.\n\nSay I remember I wrote a line with the text `Git is awesome`, but I can\'t find it now. I could run:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --all -S"Git is awesome"\n```\n\nNotice I used `--all` to avoid restraining myself to commits reachable from `HEAD`.\n\nYou can also search for a regular expression, using `-G`:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --all -G"Git .* awesome"\n```\n\n### heading-formatting-log">Formatting Log\n\nConsider the default output of `git log` again:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_1-1.png)The output of  without additional switches]\n*The output of `git log` without additional switches*\n\nThe log starts from `HEAD`, and follows the parent chain.\n\nEach log entry begins with a line starting with `commit` and then the SHA-1 of the commit, perhaps followed by additional pointers that point to this commit.<br>It is then followed by the author, date, and commit message.\n\n<h4 id="heading-oneline">`--oneline`\n\nThe main difficulty with the default output of `git log` is that it is hard to understand a history with more than a few commits, as you simply don\'t see them all. \n\nIn the output of `git log` shown before, only four commit objects appeared on my screen. Using `git log --oneline` provides a more concise view, showing the SHA-1 of the commit, next to its message, and named references if relevant:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_5.png)The output of " width="473" height="214" loading="lazy">\n*The output of `git log --oneline`*\n\nIf you wish to omit the named references, you can add the `--no-decorate` switch:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_6.png)The output of " width="262" height="217" loading="lazy">\n*The output of `git log --oneline --no-decorate`*\n\nTo explicitly ask for `git log` to show decorations, you can use `git log --decorate`.\n\n<h4 id="heading-graph">`--graph`\n\n`git log --oneline` shows a compact representation. That is great when we have a linear history, perhaps on a single branch. But what happens when we have multiple branches, that may diverge from one another?\n\nConsider the output of the following command on my repository:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --oneline feature_branch_1 feature_branch_2\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_7.png)The output of " width="532" height="386" loading="lazy">\n_The output of `git log --oneline feature_branch_1 feature_branch_2`_\n\n`git log` outputs any commit reachable by `feature_branch_1`, `feature_branch_2`, or both. But what does the history look like? Did `feature_branch_2` diverge from `feature_branch_1`? Or did it diverge from `main`? It is impossible to tell from this view. \n\nThis is where `--graph` comes in handy, drawing an ASCII graph representing the branch structure of the commit history. If we add this option to the previous command:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_8.png)The output of " width="584" height="414" loading="lazy">\n_The output of `git log --oneline --graph feature_branch_1 feature_branch_2`_\n\nYou can actually *see* that `feature_branch_1` branched from `main` (as "Commit 12", `main`, is the parent of "Commit 13"), and also that `feature_branch_2` branched from `main` (as the parent of "Commit 14" is also "Commit 12").\n\nThe `*` symbol tells us which branch a certain commit is "on", so you can know for sure that "Commit 13" is on `feature_branch_1`, and not `feature_branch_2`.\n\n<h4 id="heading-prettyformat">`--pretty=format`\n\nThe above result is already very useful! Yet, it lacks a few things. We don\'t know the author or the time of the commit. These two information details were included in the default output of `git log` which was very long. Perhaps we can add them in a more compact way?\n\nBy using `--pretty=format:`, you can display the information of each commit in various ways using `printf`-style placeholders.\n\nIn the following command, the `%s`, `%an` and `%cd` placeholders are replaced by the commit\'s subject (message), author name, and the commit\'s date, respectively.\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --oneline --graph feature_branch_1 feature_branch_2 --pretty=format:"%s (%an) [%cd]"\n```\n\nThe output looks like this:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_9.png)Image" width="905" height="385" loading="lazy">\n_`git log --oneline --graph feature_branch_1 feature_branch_2 --pretty=format:"%s (%an) [%cd]`_\n\nThat\'s useful, but not really great to look at. We can then use other formatting tricks, specifically `%C(color)` that will switch the color to `color`, until reaching a `%Creset` that resets the color. To make the author name\'s yellow, you can use:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --oneline --graph feature_branch_1 feature_branch_2 --pretty=format:"%s %C(yellow)(%an)%Creset [%cd]"\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_10.png)Image" width="922" height="427" loading="lazy">\n_`git log --oneline --graph feature_branch_1 feature_branch_2 --pretty=format:"%s %C(yellow)(%an)%Creset [%cd]"`_\n\nFor some colors, like `red` or `green`, it is unnecessary to include the parenthesis, so `Cred` is enough.\n\n<h4 id="heading-how-is-git-lol-structured">How is `git lol` Structured?\n\nWhen I run `git lol`, it actually executes the following:\n\n`git log --graph --pretty=format:\'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\' --abbrev-commit`\n\nCan you take this bit by bit?\n\nYou already know `--graph`, which makes the output include an ASCII graph.\n\n`--abbrev-commit` uses a short prefix from the full SHA-1 of the commit (in my configuration, the first seven characters).\n\nThe rest is just coloring of various details about the commit:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git lol --all\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_log_11.png)Image" width="1051" height="386" loading="lazy">\n*`git lol --all`*\n\nI like this output because I find it clear. It gives me the information I need, with enough coloring so that every detail stands out without hurting my eyes. But if you prefer other information, other colors, a different order, or anything else - go ahead and tweak it to your liking.\n\n### heading-setting-an-alias">Setting an alias\n\nAs you know, I set `git lol` as an alias - that is, when I run `git lol`, it executes the long command I provided previously.\n\nHow can you create an alias in Git?\n\nThe easiest way is to use `git alias`, like so:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git config --global alias.co checkout\n```\n\nThis command sets `co` to be an alias for the command `checkout`, so you can use `git co main` instead of `git checkout main`.\n\nTo define `git lol` as an alias, you can use:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git config --global alias.lol \'log --graph --pretty=format:\'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\' --abbrev-commit\'\n```\n\n---\n\n## ---\n\n## heading-chapter-13-git-bisect">Chapter 13 - Git Bisect\n\nOops.\n\nI have a bug.\n\nYes, that happens some times, to all of us. Something in my system is broken, and I can\'t tell why. I have been debugging for a while, but the solution is not clear.\n\nI can tell that two weeks ago, this didn\'t happen. Luckily for me, I have been using Git (obviously, I know...), so I can go back in time and test a past version of my code. Indeed, in this version - everything worked fine.\n\nBut... I have made many changes in these two weeks. Alas, not just me - my entire team has contributed commits that add, delete, or modify parts of the code base. Where do I begin? Should I go over every change introduced in those two weeks?\n\nEnter - `git bisect`.\n\nThe goal of `git bisect` is help you find the commit where a bug was introduced, in an effective manner.\n\n### heading-how-does-git-bisect-work">How Does `git bisect` Work?\n\n`git bisect` first asks you to mark one commit as "bad" (where the bug occurs), and another commit as "good" (one without the bug). Then, it checks out a commit halfway between these two commits, and then asks you to identify the commit as either "good" or "bad". This process is repeated until you find the first "bad" commit.\n\nThe key here is using binary search - by looking at the halfway point and deciding if it is the new top or bottom of the list of commits, you can find the right commit efficiently. Even if you have 10,000 commits to hunt through, it only takes a maximum of 13 steps to find the first commit that introduced the bug.\n\n### heading-git-bisect-example">`git bisect` Example\n\nFor this example, I will use the repository on <a href="https://github.com/Omerr/bisect-exercise.git">https://github.com/Omerr/bisect-exercise.git</a>. To create it, I adapted the open source repository <a href="https://github.com/bast/git-bisect-exercise">https://github.com/bast/git-bisect-exercise</a> (according to its license).\n\nIn this repository, we have a single python file that is used to compute the value of pi (which is approximately `3.14`). If you run `python3 get_pi.py` on `main`, however, you will get a wrong result:\n\n![](https://freecodecamp.org/news/content/images/2023/12/bisect_1.png)A wrong result, we have a bug" width="677" height="63" loading="lazy">\n*A wrong result, we have a bug*\n\nThis branch consists of more than 500 commits.\n\nFind the first commit on this branch by using:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git log --oneline | tail -n 1\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/bisect_2.png)Image" width="839" height="66" loading="lazy">\n*`git log --oneline | tail -n 1`*\n\nIf you `checkout` to this commit and run `python3 get_pi.py` again, the result is correct:\n\n![](https://freecodecamp.org/news/content/images/2023/12/commit_1_pi.png)From the first commit, the result is valid" width="1125" height="658" loading="lazy">\n*From the first commit, the result is valid*\n\nSo somewhere between `HEAD` and commit `f0ea950`, a change was introduced that resulted in this wrong output.\n\nTo find it using `git bisect`, `start` the bisect process, and mark this commit as "good":\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git bisect start\ngit bisect good\n```\n\nBy default, `git bisect good` would take `HEAD` as the "good" commit. To mark `main` as "bad", you can use `git bisect bad main`:\n\n![](https://freecodecamp.org/news/content/images/2023/12/bisect_3.png)Image" width="947" height="174" loading="lazy">\n*`git bisect bad main`*\n\n`git bisect` checked out commit number `251`, the "middle point" of `main` branch. Does the state in this commit produce the right or wrong output?\n\n![](https://freecodecamp.org/news/content/images/2023/12/bisect_4.png)Trying again..." width="953" height="172" loading="lazy">\n*Trying again...*\n\nWe still get the wrong output, which means we can discard commits `252` through `500` (and additional commits after that), and narrow our search to commits `2` through `251`. Mark this as `bad`:\n\n![](https://freecodecamp.org/news/content/images/2023/12/bisect_5.png)Mark as " width="929" height="148" loading="lazy">\n*Mark as `bad`*\n\n`git bisect` checked out the "middle" commit (number `126`), and running the code again results in the right answer! This means that this commit is "good", and that the first "bad" commit is somewhere between `127` and `251`. Mark it as "good":\n\n![](https://freecodecamp.org/news/content/images/2023/12/bisect_6.png)Mark as " width="928" height="146" loading="lazy">\n*Mark as `good`*\n\nNice, `git bisect` takes us to commit `188`, as this is the "middle" commit between `127` and `251`. By running the code again, you can see that the result is wrong, so this is actually a "bad" commit, which means the first faulty commit is somewhere between `127` and `188`. As you can see, `git bisect` narrows down the search space by half on each iteration.\n\nCome on, now it\'s your turn - keep going from here! Test the result of `python3 get_pi.py` and use `git bisect good` or `git bisect bad` to mark the commit accordingly. What is the faulty commit?\n\nWhen you are done, use `git bisect reset` to stop the bisect process.\n\n### heading-automatic-git-bisect">Automatic `git bisect`\n\nIn the previous example, you could simply run `python3 get_pi.py` and check the result. Other times, the process of validating whether a certain commit is "good" or "bad" can be tricky, error prone, or just time consuming. \n\nIt is possible to automate the process of `git bisect` by creating code that would be executed on each iteration, returning `0` when the current commit is "good", and a value between `1-127` (inclusive), except `125`, if it should be considered "bad".\n\nThe syntax is:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git bisect run my_script arguments\n```\n\nAs this book is not about programming and doesn\'t assume you know a specific programming language, I will not show an example of implementing `my_script`. The `README.md` file in the repository used in this chapter (<a href="https://github.com/Omerr/bisect-exercise.git">https://github.com/Omerr/bisect-exercise.git</a>) includes an example for a script that you can run with `git bisect run` to automatically find the faulty commit for the previous example.\n\n---\n\n## ---\n\n## heading-chapter-14-other-useful-commands">Chapter 14 - Other Useful Commands\n\nThis chapter highlights a few commands that had have already been mentioned in previous chapters. I am putting them here together so that you can come back to them as a reference when needed.\n\n### heading-git-cherry-pick">`git cherry-pick`\n\nIntroduced in <a class="post-section-overview" href="#heading-chapter-8-understanding-git-rebase">chapter 8</a>, this command takes a given commit, computes the **patch** this commit introduces by computing the difference between the parent\'s commit and the commit itself, and then `cherry-pick` "replays" this difference. It is like "copy-pasting" a commit, that is, the diff this commit introduced.\n\nIn <a class="post-section-overview" href="#heading-chapter-8-understanding-git-rebase">chapter 8</a> we considered the difference introduced by "Commit 5" (using `git diff main <SHA_OF_COMMIT_5>`):\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_diff_main_commit_5-1.png)Running  to observe the patch introduced by \'Commit 5\'" width="791" height="362" loading="lazy">\n*Running `git diff` to observe the patch introduced by "Commit 5"*\n\nYou can see that in this commit, John started working on a song called "Lucy in the Sky with Diamonds":\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_diff_main_commit_5_output-1.png)The output of  - the patch introduced by \'Commit 5\'" width="1189" height="786" loading="lazy">\n*The output of `git diff` - the patch introduced by "Commit 5"*\n\nAs a reminder, you can also use the command `git show` to get the same output:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git show <SHA_OF_COMMIT_<span class="token file-descriptor important">5>\n```\n\nNow, if you `cherry-pick` this commit, you will introduce *this change* specifically, on the active branch. You can switch to `main` branch:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git checkout main (or git switch main)\n```\n\nAnd create another branch:\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git checkout -b my_branch (or git switch -c my_branch)\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/create_my_branch-1.png)Creating  that branches from " width="801" height="493" loading="lazy">\n_Creating `my_branch` that branches from `main`_\n\nNext, `cherry-pick` "Commit 5":\n\n<pre class="language-bash" tabindex="0"><code class="language-bash">git cherry-pick <SHA_OF_COMMIT_<span class="token file-descriptor important">5>\n```\n\n![](https://freecodecamp.org/news/content/images/2023/12/cherry_pick_commit_5-1.png)Using  to apply the changes introduced in \'Commit 5\' onto " width="801" height="685" loading="lazy">\n*Using `cherry-pick` to apply the changes introduced in "Commit 5" onto `main`*\n\nConsider the log (output of `git lol`):\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_lol_commit_5-1.png)The output of " width="1055" height="191" loading="lazy">\n*The output of `git lol`*\n\nIt seems like you *copy-pasted* "Commit 5". Remember that even though it has the same commit message, and introduces the same changes, and even points to the same tree object as the original "Commit 5" in this case - it is still a different commit object, as it was created with a different timestamp.\n\nLooking at the changes, using `git show HEAD`:\n\n![](https://freecodecamp.org/news/content/images/2023/12/git_show_HEAD-3.png)The output of " width="862" height="643" loading="lazy">\n*The output of `git show HEAD`*\n\nThey are the same as "Commit 5"\'s.\n\n### heading-git-revert-1">`git revert`\n\n`git revert` is essentially the reverse of `git cherry-pick`, introduced in <a class="post-section-overview" href="#heading-chapter-10-additional-tools-for-undoing-changes">chapter 10</a>. This command takes the commit you\'re providing it with and computes the diff from its parent commit, just like `git cherry-pick`, but this time, it computes the *reverse* changes. That is, if in the specified commit you added a line, the reverse would delete the line, and vice versa.\n\n### heading-git-add-p">`git add -p`\n\nStaging changes is an integral part of introducing changes to Git. Sometimes, you wish to stage all changes together (with `git add .`), or perhaps stage all changes of a specific file (using `git add <file_path>`). Yet there are times where it would be convenient to stage only certain parts of modified files.\n\nIn <a href="https://freecodecamp.org/news/p/f7b355ea-3f22-4613-8218-e95c67779d9f/chapter-6-diffs-and-patches">chapter 6</a>, we introduced `git add -p`. This command allows you to stage certain parts of files, by splitting them into hunks (`p` stands for `patch`). For example, say you have this file, `my_file.py`:\n\n![`my_file.py`](https://freecodecamp.org/news/content/images/2023/12/my_file_py_1.png)\n\nYou then modify this file - by changing text within `function_1`, and also adding a new function, `function_5`:\n\n![`my_file.py` after the changes](https://freecodecamp.org/news/content/images/2023/12/my_file_py_2.png)\n\nIf you used `git add my_file.py` at this point, you would stage both of these changes together. In case you want to separate them into different commits, you could use `git add -p`, which splits these two changes and asks you about each one as a standalone hunk:\n\n![`git add -p`](https://freecodecamp.org/news/content/images/2023/12/add_p_1.png)\n\nBy typing `?`, you can see what the different options stand for:\n\n![Using a `?` to get a description of the different options](https://freecodecamp.org/news/content/images/2023/12/add_p_2.png)\n\nIn this case, say we only want to stage the change introducing `function_5`. We do not want to stage the change of `function_1`, so we select `n`:\n\n![Not staging the change to `function_1`](https://freecodecamp.org/news/content/images/2023/12/add_p_3.png)\n__\n\nNext, we are prompted for the second change - the one introducing `function_5`. We want to stage this hunk indeed, to can do so we can type `y`.\n\n')])}const v=r(d,[["render",y],["__file","part-4-amazing-and-useful-git-tools.html.vue"]]),T=JSON.parse('{"path":"/freecodecamp.org/gitting-things-done-book/part-4-amazing-and-useful-git-tools.html","title":"Part 4 - Amazing and Useful Git Tools","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Part 4 - Amazing and Useful Git Tools","description":"Article(s) > (5/6) Gitting Things Done ‚Äì A Visual and Practical Guide to Git [Full Book]","category":["Git","Article(s)"],"tag":["blog","freecodecamp.org","git"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > (5/6) Gitting Things Done ‚Äì A Visual and Practical Guide to Git [Full Book]"},{"property":"og:description","content":"Part 4 - Amazing and Useful Git Tools"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/freecodecamp.org/gitting-things-done-book/part-4-amazing-and-useful-git-tools.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/freecodecamp.org/gitting-things-done-book/part-4-amazing-and-useful-git-tools.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Part 4 - Amazing and Useful Git Tools"}],["meta",{"property":"og:description","content":"Article(s) > (5/6) Gitting Things Done ‚Äì A Visual and Practical Guide to Git [Full Book]"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://freecodecamp.org/news/content/images/size/w2000/2023/12/Gitting-Things-Done-Cover-with-Photo.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://freecodecamp.org/news/content/images/size/w2000/2023/12/Gitting-Things-Done-Cover-with-Photo.png"}],["meta",{"name":"twitter:image:alt","content":"Part 4 - Amazing and Useful Git Tools"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"freecodecamp.org"}],["meta",{"property":"article:tag","content":"git"}],["meta",{"property":"article:published_time","content":"2024-01-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Part 4 - Amazing and Useful Git Tools\\",\\"image\\":[\\"https://freecodecamp.org/news/content/images/2023/12/git_log_1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_2-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_3.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_1-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_5.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_6.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_7.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_8.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_9.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_10.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_log_11.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/bisect_1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/bisect_2.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/commit_1_pi.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/bisect_3.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/bisect_4.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/bisect_5.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/bisect_6.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_diff_main_commit_5-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_diff_main_commit_5_output-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/create_my_branch-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/cherry_pick_commit_5-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_lol_commit_5-1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/git_show_HEAD-3.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/my_file_py_1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/my_file_py_2.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/add_p_1.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/add_p_2.png\\",\\"https://freecodecamp.org/news/content/images/2023/12/add_p_3.png\\"],\\"datePublished\\":\\"2024-01-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"date":"2024-01-08T00:00:00.000Z","isOriginal":false,"cover":"https://freecodecamp.org/news/content/images/size/w2000/2023/12/Gitting-Things-Done-Cover-with-Photo.png"},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":15.08,"words":4525},"filePathRelative":"freecodecamp.org/gitting-things-done-book/part-4-amazing-and-useful-git-tools.md","localizedDate":"2024ÎÖÑ 1Ïõî 8Ïùº","excerpt":"\\n"}');export{v as comp,T as data};
