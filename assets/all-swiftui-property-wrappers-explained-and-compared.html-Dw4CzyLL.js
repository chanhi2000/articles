import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,b as e,t as u,e as o,n as s,g as l,w as a,d as t,f as w,r as d,o as m}from"./app-BgNevrm5.js";const g={},f={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},y={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},b={class:"table-of-contents"},v=e("hr",null,null,-1),_=e("blockquote",null,[e("p",null,"Updated for Xcode 15")],-1),S=e("p",null,"SwiftUI offers 17 property wrappers for our applications, each of which provide different functionality. Knowing which one to use and when is critical to getting things right, so in this article I‚Äôm going to introduce you to each of them, and give you clear guidance which to use.",-1),k=e("hr",null,null,-1),I=e("h2",{id:"tl-dr",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#tl-dr"},[e("span",null,"TL;DR")])],-1),x=e("p",null,"I‚Äôm going to explain more in a moment, but here‚Äôs the ‚Äútoo long; didn‚Äôt read‚Äù summary that describes roughly what each wrapper does, whether it owns its data or not (i.e. whether the data belongs to it and is managed by it), along with links to more:",-1),A=e("code",null,"@AppStorage",-1),U=e("code",null,"UserDefaults",-1),T=e("code",null,"@Binding",-1),O=e("code",null,"@Environment",-1),j=e("code",null,"@EnvironmentObject",-1),D=e("code",null,"@FetchRequest",-1),E=e("li",null,[e("code",null,"@FocusedBinding"),t(" is designed to watch for values in the key window, such as a text field that is currently selected. This does not own its data.")],-1),R=e("li",null,[e("code",null,"@FocusedValue"),t(" is a simpler version of "),e("code",null,"@FocusedBinding"),t(" that doesn‚Äôt unwrap the bound value for you. This does not own its data.")],-1),M=e("code",null,"@GestureState",-1),B=e("li",null,[e("code",null,"@Namespace"),t(" creates an animation namespace to allow matched geometry effects, which can be shared by other views. This owns its data.")],-1),P=e("li",null,[e("code",null,"@NSApplicationDelegateAdaptor"),t(" is used to create and register a class as the app delegate for a macOS app. This owns its data.")],-1),N=e("code",null,"@ObservedObject",-1),q=e("code",null,"ObservableObject",-1),F=e("code",null,"@Published",-1),C=e("code",null,"ObservableObject",-1),L=e("code",null,"@ScaledMetric",-1),V=e("code",null,"@SceneStorage",-1),K=e("code",null,"@State",-1),z=e("code",null,"@StateObject",-1),Y=e("code",null,"ObservableObject",-1),G=e("code",null,"@UIApplicationDelegateAdaptor",-1),H=w('<hr><h2 id="storing-temporary-data" tabindex="-1"><a class="header-anchor" href="#storing-temporary-data"><span>Storing temporary data</span></a></h2><p>When it comes to storing data in your app, the simplest property wrapper is <code>@State</code>. This is designed to store value types that are used locally by your view, so it‚Äôs great for storing integers, Booleans, and even local instances of structs.</p><p>In comparison, <code>@Binding</code> is used for simple data that you want to change, but is <em>not</em> owned by your view. As an example, think of how the built-in <code>Toggle</code> switch works: it needs to move between on and off states, but it doesn‚Äôt want to store that value itself so instead it has a binding to some external value that <em>we</em> own. So, our view has an <code>@State</code> property, and the <code>Toggle</code> has an <code>@Binding</code> property.</p><p>There is a variation of <code>@State</code> called <code>@GestureState</code>, specifically for tracking active gestures. This isn‚Äôt used so often, but it does have the benefit that it sets your property back to its initial value when the gesture ends.</p><p>For more advanced purposes ‚Äì i.e., dealing with classes, or sharing data in many places ‚Äì you should <em>not</em> use <code>@State</code> and <code>@Binding</code>. Instead, you should create your object somewhere using <code>@StateObject</code>, then use it in other views with <code>@ObservedObject</code>.</p><p><strong>A simple rule is this: if you see ‚Äústate‚Äù in the name of a property wrapper, it means that views definitely owns the data.</strong></p><p>So, <code>@State</code> means simple value type data created and managed locally but perhaps shared elsewhere using <code>@Binding</code>, and <code>@StateObject</code> means reference type data created and managed locally, but perhaps shared elsewhere using something like <code>@ObservedObject</code>.</p><p>This is important: if you ever see <code>@ObservedObject var something = SomeType()</code> it should almost certainly be <code>@StateObject</code> instead so that SwiftUI knows the view should own the data rather than just refer to it elsewhere. Using <code>@ObservedObject</code> here can sometimes cause your app to crash because the object is destroyed prematurely.</p><p>If you find yourself handing the same data from view to view to view, you‚Äôll find the <code>@EnvironmentObject</code> property wrapper useful. This lets you read a reference type object from a shared environment, rather than passing it around explicitly.</p><p>Just like <code>@ObservedObject</code>, <code>@EnvironmentObject</code> should <em>not</em> be used to create your object initially. Instead, create it in a different view and use the <code>environmentObject()</code> modifier to inject it into the environment. Although the environment will automatically keep ownership of your object, you can also use <code>@StateObject</code> to store it wherever it was originally created. This is <em>not</em> required, though: putting an object into the environment is enough to keep it alive without further ownership.</p><p>The final state-based property wrapper is <code>@Published</code>, which is used <em>inside</em> your reference types to annotate the properties. Any property marked with <code>@Published</code> will cause its parent class to announce that a change has occurred, which in turn will cause any view observing that object to make any changes it needs.</p><hr><h2 id="storing-long-term-data" tabindex="-1"><a class="header-anchor" href="#storing-long-term-data"><span>Storing long-term data</span></a></h2><p>SwiftUI has three property wrappers designed to store and/or retrieve data.</p><p>The first is <code>@AppStorage</code>, which is a wrapper around <code>UserDefaults</code>. Every time you read or write a value from app storage, you‚Äôre actually reading or writing from <code>UserDefaults</code>.</p><p>The second is <code>@SceneStorage</code>, which is a wrapper around Apple‚Äôs state restoration APIs. State restoration is what allows an app to be closed and reloaded, and come back to the same state the user left off ‚Äì it makes it look like our apps were always running, even though they were silently terminated.</p><p><strong><code>@AppStorage</code> and <code>@SceneStorage</code> are <em>not</em> secure and should <em>not</em> be used to store sensitive data.</strong></p><p>Although <code>@AppStorage</code> and <code>@SceneStorage</code> sound the same, they are not: <code>@AppStorage</code> stores one value for your entire application, whereas <code>@SceneStorage</code> will automatically save multiple values for the same data for times when the user has your app window open multiple times ‚Äì think iPadOS and macOS.</p><p>So, you might use <code>@AppStorage</code> to store global values such as ‚Äúwhat is the user‚Äôs high score?‚Äù, and you might use <code>@SceneStorage</code> to store ‚Äúwhat page is the user reading right now?‚Äù</p><p>The third data property wrapper is <code>@FetchRequest</code>, which is used to retrieve information from Core Data. This will automatically use whichever managed object context is in the environment, and update itself when the underlying data has changed.</p><hr><h2 id="reading-environment-data" tabindex="-1"><a class="header-anchor" href="#reading-environment-data"><span>Reading environment data</span></a></h2><p>SwiftUI has two properties wrappers for reading the user‚Äôs environment: <code>@Environment</code> and <code>@ScaledMetric</code>.</p><p><code>@Environment</code> is used to read a wide variety of data such as what trait collection is currently active, whether they are using a 2x or 3x screen, what timezone they are on, and more. It also has a couple of special application actions, such as exporting files and opening a URL in the system-registered web browser.</p><p><code>@ScaledMetric</code> is much simpler, and lets us adapt the size of our user interface based on a user‚Äôs Dynamic Type settings. For example, a box that is 100x100 points might look great using the system default size, but with <code>@ScaledMetric</code> it will automatically become 200x200 when a larger Dynamic Type setting is enabled.</p><hr><h2 id="referring-to-views" tabindex="-1"><a class="header-anchor" href="#referring-to-views"><span>Referring to views</span></a></h2><p>SwiftUI provides the <code>@Namespace</code> property wrapper, which creates a new namespace for animations. Animation namespaces let us say ‚Äúanimate views with an ID of 5‚Äù, and all views in that namespace with the ID 5 will be animated.</p><p>You can share namespaces between views by using the property type <code>Namespace.ID</code> and injecting the <code>@Namespace</code> value from whichever view created it. This allows you to created matched geometry effect animations across views, rather than storing all the data in the current view.</p><hr><h2 id="application-handling" tabindex="-1"><a class="header-anchor" href="#application-handling"><span>Application handling</span></a></h2><p>If you ever need access to the old <code>UIApplicationDelegate</code> and <code>NSApplicationDelegate</code> methods and notifications, you should use the <code>@UIApplicationDelegateAdaptor</code> and <code>@NSApplicationDelegateAdaptor</code> property wrappers respectively.</p><p>You provide these with the class of your app delegate, and they will make sure an instance is created and sent all appropriate notifications.</p><hr><h2 id="sources-of-truth" tabindex="-1"><a class="header-anchor" href="#sources-of-truth"><span>Sources of truth</span></a></h2><p>Earlier I described which property wrappers own their data, and really this comes to sources of truth in your application: wrappers that own their data are sources of truth because they create and manage the value, and wrappers that do <em>not</em> own their data are <em>not</em> sources of truth because they get the value from somewhere else.</p><p><strong><em>Property wrappers that are sources of truth</em></strong></p><p>These create and manage values directly:</p><ul><li><code>@AppStorage</code></li><li><code>@FetchRequest</code></li><li><code>@GestureState</code></li><li><code>@Namespace</code></li><li><code>@NSApplicationDelegateAdaptor</code></li><li><code>@Published</code></li><li><code>@ScaledMetric</code></li><li><code>@SceneStorage</code></li><li><code>@State</code></li><li><code>@StateObject</code></li><li><code>@UIApplicationDelegateAdaptor</code></li></ul><p><strong><em>Property wrappers that are not sources of truth</em></strong></p><p>These get their values from somewhere else:</p><ul><li><code>@Binding</code></li><li><code>@Environment</code></li><li><code>@EnvironmentObject</code></li><li><code>@FocusedBinding</code></li><li><code>@FocusedValue</code></li><li><code>@ObservedObject</code></li></ul><hr><h2 id="if-you-remember-nothing-else" tabindex="-1"><a class="header-anchor" href="#if-you-remember-nothing-else"><span>If you remember nothing else‚Ä¶</span></a></h2><p><strong>I want to make a new property owned by the current view.</strong> You should use <code>@State</code> for value types, and <code>@StateObject</code> for reference types.</p><p><strong>I want to refer to a value created elsewhere.</strong> You should use <code>@Binding</code> for value types, and either <code>@ObservedObject</code> or <code>@EnvironmentObject</code> for reference types.</p>',47),Z={class:"hint-container details"},J=e("summary",null,"Similar solutions‚Ä¶",-1);function W(c,X){const r=d("VPCard"),n=d("router-link"),i=d("RouteLink");return m(),h("div",null,[e("h1",f,[e("a",y,[e("span",null,u(c.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),o(r,s(l({title:"SwiftUI by Example",desc:"Back to Home",link:"/hackingwithswift.com/swiftui/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),e("nav",b,[e("ul",null,[e("li",null,[o(n,{to:"#tl-dr"},{default:a(()=>[t("TL;DR")]),_:1})]),e("li",null,[o(n,{to:"#storing-temporary-data"},{default:a(()=>[t("Storing temporary data")]),_:1})]),e("li",null,[o(n,{to:"#storing-long-term-data"},{default:a(()=>[t("Storing long-term data")]),_:1})]),e("li",null,[o(n,{to:"#reading-environment-data"},{default:a(()=>[t("Reading environment data")]),_:1})]),e("li",null,[o(n,{to:"#referring-to-views"},{default:a(()=>[t("Referring to views")]),_:1})]),e("li",null,[o(n,{to:"#application-handling"},{default:a(()=>[t("Application handling")]),_:1})]),e("li",null,[o(n,{to:"#sources-of-truth"},{default:a(()=>[t("Sources of truth")]),_:1})]),e("li",null,[o(n,{to:"#if-you-remember-nothing-else"},{default:a(()=>[t("If you remember nothing else‚Ä¶")]),_:1})])])]),v,o(r,s(l({title:"All SwiftUI property wrappers explained and compared | SwiftUI by Example",desc:"All SwiftUI property wrappers explained and compared",link:"https://hackingwithswift.com/quick-start/swiftui/all-swiftui-property-wrappers-explained-and-compared",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),_,S,k,I,x,e("ul",null,[e("li",null,[A,t(" reads and writes values from "),U,t(". This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-appstorage-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[T,t(" refers to value type data owned by a different view. Changing the binding locally changes the remote data too. This does not own its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-binding-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[O,t(" lets us read data from the system, such as color scheme, accessibility options, and trait collections, but you can add your own keys here if you want. This does not own its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-environment-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[j,t(" reads a shared object that we placed into the environment. This does not own its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-environmentobject-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[D,t(" starts a Core Data fetch request for a particular entity. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-fetchrequest-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),E,R,e("li",null,[M,t(" stores values associated with a gesture that is currently in progress, such as how far you have swiped, except it will be reset to its default value when the gesture stops. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-gesturestate-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),B,P,e("li",null,[N,t(" refers to an instance of an external class that conforms to the "),q,t(" protocol. This does not own its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-observedobject-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[F,t(" is attached to properties inside an "),C,t(", and tells SwiftUI that it should refresh any views that use this property when it is changed. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-published-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[L,t(" reads the user‚Äôs Dynamic Type setting and scales numbers up or down based on an original value you provide. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-scaledmetric-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[V,t(" lets us save and restore small amounts of data for state restoration. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-scenestorage-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[K,t(" lets us manipulate small amounts of value type data locally to a view. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-state-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[z,t(" is used to store new instances of reference type data that conforms to the "),Y,t(" protocol. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-stateobject-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})]),e("li",null,[G,t(" is used to create and register a class as the app delegate for an iOS app. This owns its data. "),o(i,{to:"/hackingwithswift.com/swiftui/what-is-the-uiapplicationdelegateadaptor-property-wrapper.html"},{default:a(()=>[t("More info.")]),_:1})])]),H,e("details",Z,[J,o(r,s(l({title:"Understanding property wrappers in Swift and SwiftUI | SwiftUI by Example",desc:"Understanding property wrappers in Swift and SwiftUI",link:"/hackingwithswift.com/swiftui/understanding-property-wrappers-in-swift-and-swiftui.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(r,s(l({title:"SwiftUI tips and tricks | SwiftUI by Example",desc:"SwiftUI tips and tricks",link:"/hackingwithswift.com/swiftui/swiftui-tips-and-tricks.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(r,s(l({title:"How to use Instruments to profile your SwiftUI code and identify slow layouts | SwiftUI by Example",desc:"How to use Instruments to profile your SwiftUI code and identify slow layouts",link:"/hackingwithswift.com/swiftui/how-to-use-instruments-to-profile-your-swiftui-code-and-identify-slow-layouts.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(r,s(l({title:"Answering the big question: should you learn SwiftUI, UIKit, or both? | SwiftUI by Example",desc:"Answering the big question: should you learn SwiftUI, UIKit, or both?",link:"/hackingwithswift.com/swiftui/answering-the-big-question-should-you-learn-swiftui-uikit-or-both.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(r,s(l({title:"Building a menu using List | SwiftUI by Example",desc:"Building a menu using List",link:"/hackingwithswift.com/swiftui/building-a-menu-using-list.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16)])])}const ee=p(g,[["render",W],["__file","all-swiftui-property-wrappers-explained-and-compared.html.vue"]]),te=JSON.parse('{"path":"/hackingwithswift.com/swiftui/all-swiftui-property-wrappers-explained-and-compared.html","title":"All SwiftUI property wrappers explained and compared","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"All SwiftUI property wrappers explained and compared","description":"Article(s) > All SwiftUI property wrappers explained and compared","category":["Swift","SwiftUI","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","swiftui","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > All SwiftUI property wrappers explained and compared"},{"property":"og:description","content":"All SwiftUI property wrappers explained and compared"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftui/all-swiftui-property-wrappers-explained-and-compared.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftui/all-swiftui-property-wrappers-explained-and-compared.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"All SwiftUI property wrappers explained and compared"}],["meta",{"property":"og:description","content":"Article(s) > All SwiftUI property wrappers explained and compared"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftui"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2024-05-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"All SwiftUI property wrappers explained and compared\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"date":"2024-05-01T00:00:00.000Z","isOriginal":false},"headers":[{"level":2,"title":"TL;DR","slug":"tl-dr","link":"#tl-dr","children":[]},{"level":2,"title":"Storing temporary data","slug":"storing-temporary-data","link":"#storing-temporary-data","children":[]},{"level":2,"title":"Storing long-term data","slug":"storing-long-term-data","link":"#storing-long-term-data","children":[]},{"level":2,"title":"Reading environment data","slug":"reading-environment-data","link":"#reading-environment-data","children":[]},{"level":2,"title":"Referring to views","slug":"referring-to-views","link":"#referring-to-views","children":[]},{"level":2,"title":"Application handling","slug":"application-handling","link":"#application-handling","children":[]},{"level":2,"title":"Sources of truth","slug":"sources-of-truth","link":"#sources-of-truth","children":[]},{"level":2,"title":"If you remember nothing else‚Ä¶","slug":"if-you-remember-nothing-else","link":"#if-you-remember-nothing-else","children":[]}],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":6.9,"words":2071},"filePathRelative":"hackingwithswift.com/swiftui/all-swiftui-property-wrappers-explained-and-compared.md","localizedDate":"2024ÎÖÑ 5Ïõî 1Ïùº","excerpt":"\\n"}');export{ee as comp,te as data};
