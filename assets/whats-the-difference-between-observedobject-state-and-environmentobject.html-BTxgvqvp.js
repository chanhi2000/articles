import{_ as b}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as u,b as e,t as m,e as t,n,g as s,w as r,d as o,f as h,r as c,o as w}from"./app-BgNevrm5.js";const f={},v={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},y={class:"table-of-contents"},j=e("hr",null,null,-1),k=h(`<blockquote><p>Updated for Xcode 15</p></blockquote><p>State is inevitable in any modern app, but with SwiftUI it&#39;s important to remember that all of our views are simply functions of their state â€“ we don&#39;t change the views directly, but instead manipulate the state and let <em>that</em> dictate the result.</p><p>SwiftUI gives us several ways of storing state in our application, but they are subtly different and it&#39;s important to understand <em>how</em> they are different in order to use the framework properly.</p><p>The simplest way of working with state is the <code>@State</code> property wrapper, used like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">ContentView</span><span class="token punctuation">:</span> <span class="token class-name">View</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token attribute atrule">@State</span> <span class="token keyword">private</span> <span class="token keyword">var</span> tapCount <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">View</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Button</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Tap count: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">tapCount</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            tapCount <span class="token operator">+=</span> <span class="token number">1</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),O={href:"https://hackingwithswift.com/files/projects/swiftui/whats-the-difference-between-atobservedobject-atstate-and-atenvironmentobject-1.zip",target:"_blank",rel:"noopener noreferrer"},S=h('<p>This creates a property inside a view, but it uses the <code>@State</code> property wrapper to ask SwiftUI to manage the memory. This <em>matters</em>: all our views are structs, which means they can&#39;t be changed, and if we weren&#39;t even able to modify an integer in our apps then there wouldn&#39;t be much we <em>could</em> do.</p><p>So, when we say <code>@State</code> to make a property, we hand control over it to SwiftUI so that it remains persistent in memory for as long as the view exists. When that state changes, SwiftUI knows to automatically reload the view with the latest changes so it can reflect its new information.</p><p><code>@State</code> is great for simple properties that belong to a specific view and never get used outside that view, so as a result it&#39;s important to mark those properties as being private to re-enforce the idea that such state is specifically designed never to escape its view.</p><hr><h2 id="what-is-observedobject" tabindex="-1"><a class="header-anchor" href="#what-is-observedobject"><span>What is @ObservedObject?</span></a></h2><p>For more complex properties â€“ when you have a custom type you want to use that might have multiple properties and methods, or might be shared across multiple views â€“ you will often use <code>@ObservedObject</code> instead.</p><p>This is very similar to <code>@State</code> except now we&#39;re using an external reference type rather than a simple local property like a string or an integer. You&#39;re still saying that your view depends on data that will change, except now it&#39;s data you&#39;re responsible for managing yourself â€“ you need to create an instance of the class, create its own properties, and so on.</p><p>Whatever type you use with <code>@ObservedObject</code> should conform to the <code>ObservableObject</code> protocol. When you add properties to observable objects you get to decide whether changes to each property should force views that are watching your object to refresh or not. You usually will, but it&#39;s not required.</p><p>There are several ways for an observed object to notify views that important data has changed, but the easiest is using the <code>@Published</code> property wrapper. You can also use custom publishers from the Combine framework if you need more control, but realistically this will be very rare. If the observable object happens to have several views using its data, either option will automatically notify them all.</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>When you use a custom publisher to announce that your object has changed, this <em>must</em> happen on the main thread.</p></div><hr><h2 id="what-is-stateobject" tabindex="-1"><a class="header-anchor" href="#what-is-stateobject"><span>What is @StateObject?</span></a></h2><p>Somewhere between <code>@State</code> and <code>@ObservedObject</code> lies <code>@StateObject</code>. This is a specialized version of <code>@ObservedObject</code>, and it works in almost exactly the same way: you must conform to the <code>ObservableObject</code> protocol, you can use <code>@Published</code> to mark properties as causing change notifications, and any views that watch an <code>@StateObject</code> will refresh their body when the object changes.</p><p>There is one important difference between <code>@StateObject</code> and <code>@ObservedObject</code>, which is <em>ownership</em> â€“ which view <em>created</em> the object, and which view is just <em>watching</em> it.</p><p>The rule is this: whichever view is the first to create your object must use <code>@StateObject</code>, to tell SwiftUI it is the owner of the data and is responsible for keeping it alive. All other views must use <code>@ObservedObject</code>, to tell SwiftUI they want to watch the object for changes but don&#39;t own it directly.</p><hr><h2 id="what-is-environmentobject" tabindex="-1"><a class="header-anchor" href="#what-is-environmentobject"><span>What is @EnvironmentObject?</span></a></h2><p>You&#39;ve seen how <code>@State</code> declares simple properties for a type that automatically cause a refresh of the view when it changes, and how <code>@ObservedObject</code> declares a property for an external type that may or may not cause a refresh of the view when it changes. Both of these two must be set by your view, but <code>@ObservedObject</code> might be shared with other views.</p><p>There&#39;s another type of property wrapper available to use, which is <code>@EnvironmentObject</code>. This is a value that is made available to your views through the application itself â€“ it&#39;s shared data that every view can read if they want to. So, if your app had some important model data that all views needed to read, you could either hand it from view to view to view or just put it into the environment where every view has instant access to it.</p><p>Think of <code>@EnvironmentObject</code> as a massive convenience for times when you need to pass lots of data around your app. Because all views point to the same model, if one view changes the model all views immediately update â€“ there&#39;s no risk of getting different parts of your app out of sync.</p><hr><h2 id="summing-up-the-differences" tabindex="-1"><a class="header-anchor" href="#summing-up-the-differences"><span>Summing up the differences</span></a></h2><ul><li>Use <code>@State</code> for simple properties that belong to a single view. They should usually be marked <code>private</code>.</li><li>Use <code>@ObservedObject</code> for complex properties that might belong to several views. Most times you&#39;re using a reference type you should be using <code>@ObservedObject</code> for it.</li><li>Use <code>@StateObject</code> once for each observable object you use, in whichever part of your code is responsible for creating it.</li><li>Use <code>@EnvironmentObject</code> for properties that were created elsewhere in the app, such as shared data.</li></ul><p>Of the four you will find that <code>@ObservedObject</code> is both the most useful and the most commonly used, so if you&#39;re not sure which to use start there.</p>',24),_={class:"hint-container details"},E=e("summary",null,"Similar solutionsâ€¦",-1);function x(l,W){const a=c("VPCard"),i=c("router-link"),p=c("FontIcon"),d=c("VidStack");return w(),u("div",null,[e("h1",v,[e("a",g,[e("span",null,m(l.$frontmatter.title)+" ê´€ë ¨",1)])]),t(a,n(s({title:"SwiftUI by Example",desc:"Back to Home",link:"/hackingwithswift.com/swiftui/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),e("nav",y,[e("ul",null,[e("li",null,[t(i,{to:"#what-is-observedobject"},{default:r(()=>[o("What is @ObservedObject?")]),_:1})]),e("li",null,[t(i,{to:"#what-is-stateobject"},{default:r(()=>[o("What is @StateObject?")]),_:1})]),e("li",null,[t(i,{to:"#what-is-environmentobject"},{default:r(()=>[o("What is @EnvironmentObject?")]),_:1})]),e("li",null,[t(i,{to:"#summing-up-the-differences"},{default:r(()=>[o("Summing up the differences")]),_:1})])])]),j,t(a,n(s({title:"What's the difference between @ObservedObject, @State, and @EnvironmentObject? | SwiftUI by Example",desc:"What's the difference between @ObservedObject, @State, and @EnvironmentObject?",link:"https://hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),k,e("blockquote",null,[e("p",null,[e("a",O,[t(p,{icon:"fas fa-file-zipper"}),o("Download this as an Xcode project")])])]),t(d,{src:"https://hackingwithswift.com/img/books/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject-1.mp4"}),S,e("details",_,[E,t(a,n(s({title:"How to use @EnvironmentObject to share data between views | SwiftUI by Example",desc:"How to use @EnvironmentObject to share data between views",link:"/hackingwithswift.com/swiftui/how-to-use-environmentobject-to-share-data-between-views.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,n(s({title:"How to use @ObservedObject to manage state from external objects | SwiftUI by Example",desc:"How to use @ObservedObject to manage state from external objects",link:"/hackingwithswift.com/swiftui/how-to-use-observedobject-to-manage-state-from-external-objects.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,n(s({title:"What is the @EnvironmentObject property wrapper? | SwiftUI by Example",desc:"What is the @EnvironmentObject property wrapper?",link:"/hackingwithswift.com/swiftui/what-is-the-environmentobject-property-wrapper.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,n(s({title:"Adding items to an order with @EnvironmentObject | SwiftUI by Example",desc:"Adding items to an order with @EnvironmentObject",link:"/hackingwithswift.com/swiftui/adding-items-to-an-order-with-environmentobject.html",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,n(s({title:"What is the @ObservedObject property wrapper? | SwiftUI by Example",desc:"What is the @ObservedObject property wrapper?",link:"/hackingwithswift.com/swiftui/what-is-the-observedobject-property-wrapper.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16)])])}const T=b(f,[["render",x],["__file","whats-the-difference-between-observedobject-state-and-environmentobject.html.vue"]]),V=JSON.parse(`{"path":"/hackingwithswift.com/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject.html","title":"What's the difference between @ObservedObject, @State, and @EnvironmentObject?","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"What's the difference between @ObservedObject, @State, and @EnvironmentObject?","description":"Article(s) > What's the difference between @ObservedObject, @State, and @EnvironmentObject?","category":["Swift","SwiftUI","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","swiftui","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > What's the difference between @ObservedObject, @State, and @EnvironmentObject?"},{"property":"og:description","content":"What's the difference between @ObservedObject, @State, and @EnvironmentObject?"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"What's the difference between @ObservedObject, @State, and @EnvironmentObject?"}],["meta",{"property":"og:description","content":"Article(s) > What's the difference between @ObservedObject, @State, and @EnvironmentObject?"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftui"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"What's the difference between @ObservedObject, @State, and @EnvironmentObject?\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/hackingwithswift.com/swiftui/how-to-detect-the-location-of-a-tap-inside-a-view.md"},"headers":[{"level":2,"title":"What is @ObservedObject?","slug":"what-is-observedobject","link":"#what-is-observedobject","children":[]},{"level":2,"title":"What is @StateObject?","slug":"what-is-stateobject","link":"#what-is-stateobject","children":[]},{"level":2,"title":"What is @EnvironmentObject?","slug":"what-is-environmentobject","link":"#what-is-environmentobject","children":[]},{"level":2,"title":"Summing up the differences","slug":"summing-up-the-differences","link":"#summing-up-the-differences","children":[]}],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":4.56,"words":1367},"filePathRelative":"hackingwithswift.com/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject.md","excerpt":"\\n"}`);export{T as comp,V as data};
