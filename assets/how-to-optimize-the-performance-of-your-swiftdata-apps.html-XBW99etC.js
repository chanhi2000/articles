import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,b as e,t as u,e as a,n as i,g as r,w as n,f as h,r as l,o as f,d as s}from"./app-BgNevrm5.js";const m={},y={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},k={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},g={class:"table-of-contents"},w=e("hr",null,null,-1),b=h(`<blockquote><p>Updated for Xcode 15</p></blockquote><p>Although both SwiftUI and SwiftData hide a lot of implementation detail from us, there are still ways we can reduce their workload to help boost app performance.</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>As with all performance tips, make sure you benchmark your project before and after trying something listed below, because every project is different and there could be unexpected side effects that end up making your performance worse.</p></div><hr><h2 id="limit-the-amount-of-data-you-fetch" tabindex="-1"><a class="header-anchor" href="#limit-the-amount-of-data-you-fetch"><span>Limit the amount of data you fetch</span></a></h2><p>When you&#39;re running a query, you don&#39;t have to load all the data, and you don&#39;t even need to load all the values of all the data.</p><p>The primary way you can load less data is by refining your predicate: SwiftData will run your query, filter out any results that don&#39;t match your predicate, then load the remainder into the result. As you might imagine, it&#39;s usually much faster to filter out objects in the predicate than to load them into model objects and filter them in Swift.</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>Behind the scenes SwiftData might not convert your entire predicate to SQL. If you&#39;re curious what actually happens, look for the output of <code>EXPLAIN QUERY PLAN</code> in Xcode&#39;s logs when you have the <code>-com.apple.CoreData.SQLDebug</code> launch argument cranked up to 3.</p></div><p>The same is true for sorting ‚Äì if you <em>can</em> do it in SwiftData rather than Swift, you should.</p><p>This takes two other main forms, both used when creating a custom <code>FetchDescriptor</code>:</p><ol><li>If you know you&#39;ll only use certain properties from your model object, set the <code>propertiesToFetch</code> to an array of the key paths you actually need. If there are some you didn&#39;t list there but end up needing they will automatically be fetched, but you&#39;re generating extra work.</li><li>If you don&#39;t need all your results, set a custom <code>fetchLimit</code> to load only the top 100 or 500 objects. If you end up needing more, make another fetch descriptor with a <code>fetchOffset</code> so that you get paging.</li></ol><hr><h2 id="prefetch-relationships-you-definitely-need" tabindex="-1"><a class="header-anchor" href="#prefetch-relationships-you-definitely-need"><span>Prefetch relationships you definitely need</span></a></h2><p>SwiftData lazily loads all relationship data, fetching it only when accessed by your object. If you know the relationship will be used immediately, you should create a fetch descriptor with its <code>relationshipKeyPathsForPrefetching</code> set to the relationships you&#39;ll use.</p><p>When this option is provided, SwiftData will load your model and the specified relationships in a single pass, which can be more efficient than regularly fetching individual relationships as they are used.</p><hr><h2 id="order-your-predicate-checks-for-efficiency" tabindex="-1"><a class="header-anchor" href="#order-your-predicate-checks-for-efficiency"><span>Order your predicate checks for efficiency</span></a></h2><p>If you have multiple checks inside a single predicate that you know will either be evaluated often or has lots of data to filter, you should arrange them in a smart order:</p><ol><li>If you can, place the most restrictive checks first to eliminate data as quickly as possible.</li><li>Run faster checks earlier, such as preferring integer comparison to a string comparison.</li></ol><p>For the first case, think of it like this: if 90% of your objects pass your first test, and only 5% of your objects pass the second test, you could flip the two tests around and eliminate one of the two tests for the vast majority of your data.</p><p>In the second case, this can be as simple as rearranging your checks. For example, this code uses a predicate that applies a string comparison followed by an integer comparison:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">var</span> descriptor <span class="token operator">=</span> <span class="token class-name">FetchDescriptor</span><span class="token operator">&lt;</span><span class="token class-name">Employee</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">descriptor<span class="token punctuation">.</span>predicate <span class="token operator">=</span> <span class="token other-directive property">#Predicate</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>department<span class="token punctuation">.</span><span class="token function">localizedStandardContains</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Engineering&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>salary <span class="token operator">&gt;</span> <span class="token number">200_000</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This next code flips the two around, performing the integer comparison then the string comparison:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">var</span> descriptor <span class="token operator">=</span> <span class="token class-name">FetchDescriptor</span><span class="token operator">&lt;</span><span class="token class-name">Employee</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">descriptor<span class="token punctuation">.</span>predicate <span class="token operator">=</span> <span class="token other-directive property">#Predicate</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>salary <span class="token operator">&gt;</span> <span class="token number">200_000</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>department<span class="token punctuation">.</span><span class="token function">localizedStandardContains</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Engineering&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>It&#39;s a small change, but preferring the integer comparison will run an order of magnitude faster.</p><hr><h2 id="fetch-counts-when-you-only-want-the-number-of-matches" tabindex="-1"><a class="header-anchor" href="#fetch-counts-when-you-only-want-the-number-of-matches"><span>Fetch counts when you only want the number of matches</span></a></h2><p><code>ModelContext</code> has a dedicated <code>fetchCount()</code> method for times when you want to know how many objects would be returned for a given query. <em>This is significantly more efficient than fetching a whole array then reading its <code>count</code> property.</em></p><p>So, if all you want is a count, use <code>fetchCount()</code> with a custom fetch descriptor.</p><hr><h2 id="use-background-task-for-batch-inserts" tabindex="-1"><a class="header-anchor" href="#use-background-task-for-batch-inserts"><span>Use background task for batch inserts</span></a></h2><p>If you have lots of data to insert, perhaps as a result of a network call, consider doing it on a background task so that you leave Swift&#39;s main actor free to do all its work without freezing up the UI.</p><div class="hint-container important"><p class="hint-container-title">Important</p><p>Please remember that <code>ModelContext</code> and all SwiftData models are not sendable, which means they are bound to the actor where they were made. If you want to work with background tasks, pass in your <code>ModelContainer</code> object that <em>is</em> sendable, then make a local context on the other task.</p></div><hr><h2 id="push-large-data-blobs-to-external-storage" tabindex="-1"><a class="header-anchor" href="#push-large-data-blobs-to-external-storage"><span>Push large data blobs to external storage</span></a></h2><p>Saving binary data such as images and movies in external storage can dramatically improve speed and lower memory usage, because SwiftData will load them only when needed.</p><p>As an example, consider this <code>User</code> model that stores user avatar images directly inside the object:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Model</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">var</span> number<span class="token punctuation">:</span> <span class="token class-name">Int</span></span>
<span class="line">    <span class="token keyword">var</span> avatar<span class="token punctuation">:</span> <span class="token class-name">Data</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> avatar<span class="token punctuation">:</span> <span class="token class-name">Data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>number <span class="token operator">=</span> number</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>avatar <span class="token operator">=</span> avatar</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Because the <code>@Query</code> macro doesn&#39;t let us specify which fields to fetch, SwiftData will load all three into memory when loading an object ‚Äì that could easily be hundreds of megabytes of data being loaded, potentially without even being used.</p><p>A smarter alternative is to mark the very large properties as being suitable for external storage, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Attribute</span><span class="token punctuation">(</span><span class="token punctuation">.</span>externalStorage<span class="token punctuation">)</span> <span class="token keyword">var</span> avatar<span class="token punctuation">:</span> <span class="token class-name">Data</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That doesn&#39;t mean SwiftData <em>must</em> store the data externally, only that it can. Any data that <em>is</em> stored externally is loaded only when it&#39;s actually used, which makes loading both faster and lighter in memory.</p><hr><h2 id="don-t-worry-about-checking-for-changes-before-saving" tabindex="-1"><a class="header-anchor" href="#don-t-worry-about-checking-for-changes-before-saving"><span>Don&#39;t worry about checking for changes before saving</span></a></h2><p>In Core Data it was common advice to always check a view context&#39;s <code>hasChanges</code> property before trying to save, to avoid unnecessary work.</p><p>In SwiftData this advice is no longer important ‚Äì just call <code>save()</code> whenever you want, or let autosave do it for you, and you&#39;ll be fine, because there&#39;s no performance impact.</p><hr><h2 id="when-in-doubt-ask-instruments" tabindex="-1"><a class="header-anchor" href="#when-in-doubt-ask-instruments"><span>When in doubt, ask Instruments</span></a></h2><p>Xcode&#39;s Instruments tool comes with a dedicated Data Persistence instrument that&#39;s able to report back on how many fetches are being, how many faults are being triggered, and also how often saves happen.</p>`,49);function v(c,x){const o=l("VPCard"),t=l("router-link");return f(),d("div",null,[e("h1",y,[e("a",k,[e("span",null,u(c.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),a(o,i(r({title:"SwiftData by Example",desc:"Back to Home",link:"/hackingwithswift.com/swiftdata/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),e("nav",g,[e("ul",null,[e("li",null,[a(t,{to:"#limit-the-amount-of-data-you-fetch"},{default:n(()=>[s("Limit the amount of data you fetch")]),_:1})]),e("li",null,[a(t,{to:"#prefetch-relationships-you-definitely-need"},{default:n(()=>[s("Prefetch relationships you definitely need")]),_:1})]),e("li",null,[a(t,{to:"#order-your-predicate-checks-for-efficiency"},{default:n(()=>[s("Order your predicate checks for efficiency")]),_:1})]),e("li",null,[a(t,{to:"#fetch-counts-when-you-only-want-the-number-of-matches"},{default:n(()=>[s("Fetch counts when you only want the number of matches")]),_:1})]),e("li",null,[a(t,{to:"#use-background-task-for-batch-inserts"},{default:n(()=>[s("Use background task for batch inserts")]),_:1})]),e("li",null,[a(t,{to:"#push-large-data-blobs-to-external-storage"},{default:n(()=>[s("Push large data blobs to external storage")]),_:1})]),e("li",null,[a(t,{to:"#don-t-worry-about-checking-for-changes-before-saving"},{default:n(()=>[s("Don't worry about checking for changes before saving")]),_:1})]),e("li",null,[a(t,{to:"#when-in-doubt-ask-instruments"},{default:n(()=>[s("When in doubt, ask Instruments")]),_:1})])])]),w,a(o,i(r({title:"How to optimize the performance of your SwiftData apps | SwiftData by Example",desc:"How to optimize the performance of your SwiftData apps",link:"https://hackingwithswift.com/quick-start/swiftdata/how-to-optimize-the-performance-of-your-swiftdata-apps",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),b])}const _=p(m,[["render",v],["__file","how-to-optimize-the-performance-of-your-swiftdata-apps.html.vue"]]),I=JSON.parse(`{"path":"/hackingwithswift.com/swiftdata/how-to-optimize-the-performance-of-your-swiftdata-apps.html","title":"How to optimize the performance of your SwiftData apps","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"How to optimize the performance of your SwiftData apps","description":"Article(s) > How to optimize the performance of your SwiftData apps","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","swiftdata","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > How to optimize the performance of your SwiftData apps"},{"property":"og:description","content":"How to optimize the performance of your SwiftData apps"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftdata/how-to-optimize-the-performance-of-your-swiftdata-apps.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftdata/how-to-optimize-the-performance-of-your-swiftdata-apps.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"How to optimize the performance of your SwiftData apps"}],["meta",{"property":"og:description","content":"Article(s) > How to optimize the performance of your SwiftData apps"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftdata"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2023-09-30T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"How to optimize the performance of your SwiftData apps\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-30T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"date":"2023-09-30T00:00:00.000Z","isOriginal":false},"headers":[{"level":2,"title":"Limit the amount of data you fetch","slug":"limit-the-amount-of-data-you-fetch","link":"#limit-the-amount-of-data-you-fetch","children":[]},{"level":2,"title":"Prefetch relationships you definitely need","slug":"prefetch-relationships-you-definitely-need","link":"#prefetch-relationships-you-definitely-need","children":[]},{"level":2,"title":"Order your predicate checks for efficiency","slug":"order-your-predicate-checks-for-efficiency","link":"#order-your-predicate-checks-for-efficiency","children":[]},{"level":2,"title":"Fetch counts when you only want the number of matches","slug":"fetch-counts-when-you-only-want-the-number-of-matches","link":"#fetch-counts-when-you-only-want-the-number-of-matches","children":[]},{"level":2,"title":"Use background task for batch inserts","slug":"use-background-task-for-batch-inserts","link":"#use-background-task-for-batch-inserts","children":[]},{"level":2,"title":"Push large data blobs to external storage","slug":"push-large-data-blobs-to-external-storage","link":"#push-large-data-blobs-to-external-storage","children":[]},{"level":2,"title":"Don't worry about checking for changes before saving","slug":"don-t-worry-about-checking-for-changes-before-saving","link":"#don-t-worry-about-checking-for-changes-before-saving","children":[]},{"level":2,"title":"When in doubt, ask Instruments","slug":"when-in-doubt-ask-instruments","link":"#when-in-doubt-ask-instruments","children":[]}],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":4.07,"words":1220},"filePathRelative":"hackingwithswift.com/swiftdata/how-to-optimize-the-performance-of-your-swiftdata-apps.md","localizedDate":"2023ÎÖÑ 9Ïõî 30Ïùº","excerpt":"\\n"}`);export{_ as comp,I as data};
