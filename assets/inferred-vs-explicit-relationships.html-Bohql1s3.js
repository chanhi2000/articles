import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as s,t as p,e as a,n as e,g as t,f as c,r,o as d}from"./app-BgNevrm5.js";const u={},h={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},m={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},k=s("nav",{class:"table-of-contents"},[s("ul")],-1),v=s("hr",null,null,-1),f=c(`<blockquote><p>Updated for Xcode 15</p></blockquote><p>SwiftData relationships can be either inferred, where SwiftData can figure out the relationship just from your model structure, or made explicit using the <code>@Relationship</code> macro. Generally speaking you only need <code>@Relationship</code> when you want a non-default configuration; you can ignore it a lot of the time.</p><p>As an example, we could define a simple <code>Student</code> model, then use that with a <code>School</code> model:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Model</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">School</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">var</span> students<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Student</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> students<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Student</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>students <span class="token operator">=</span> students</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token attribute atrule">@Model</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">var</span> school<span class="token punctuation">:</span> <span class="token class-name">School</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> school<span class="token punctuation">:</span> <span class="token class-name">School</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>school <span class="token operator">=</span> school</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>From that simple definition, SwiftData is able to see that:</p><ol><li>Each school can have many students.</li><li>Each student must belong to precisely one school.</li></ol><p>However, these two are separate things: if we create a student and set its <code>school</code> property, SwiftData doesn‚Äôt understand to add that student to the <code>students</code> array in that school ‚Äì it doesn‚Äôt automatically infer that the relationship goes two ways.</p><p>However, if we make one small change to our <code>Student</code> model, we <em>do</em> get a property relationship inference:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Model</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">var</span> school<span class="token punctuation">:</span> <span class="token class-name">School</span><span class="token operator">?</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> school<span class="token punctuation">:</span> <span class="token class-name">School</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>school <span class="token operator">=</span> school</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The only change is that we‚Äôve marked the school as being optional, meaning that it can be nil. This happens for safety reasons, and to understand why consider this:</p><ol><li>If we have a relationship between students and schools, then setting the <code>school</code> property of a student should add it or remove it from a school‚Äôs list of students.</li><li>Equally, adding or removing a student from a school‚Äôs list of students should adjust the student‚Äôs <code>school</code> property.</li><li>So what happens if you remove a student from a school without also adding them to another school?</li></ol><p>When we defined the <code>school</code> property as being non-optional we‚Äôre saying that latter case should be impossible ‚Äì a student must <em>always</em> belong to a school. If we attempt to break this rule, SwiftData will trigger a crash in our app because we‚Äôve put it into an invalid state.</p><p>So, SwiftData takes the only safe approach by default: it will only infer the relationship when it‚Äôs safe to do so ‚Äì when it won‚Äôt inadvertently trigger a crash because we changed an array. If you see an error along the lines of, ‚Äúwarning: validation recovery attempt FAILED with Error Domain=NSCocoaErrorDomain Code=1570 %{PROPERTY}@ is a required value‚Äù then this is exactly what you‚Äôve hit: you‚Äôre trying to set a non-optional value to nil. Given that Swift refuses to let us do this directly, it‚Äôs probably happening through a relationship.</p><p>On the flip side, as soon as we made the <code>school</code> property optional, that danger went away: removing a student from the <code>students</code> array will just set their <code>school</code> property to nil, so there‚Äôs no crash risk.</p><p>The rule here is simple: if a relationship can be inferred safely, SwiftData will do so.</p><p>For the many times that isn‚Äôt enough, we can create an explicit relationship using the <code>@Relationship</code> macro on one of your two models, which spells out the connection explicitly. For example, we could change the <code>Student</code> class so its <code>school</code> property looks like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Relationship</span><span class="token punctuation">(</span>inverse<span class="token punctuation">:</span> <span class="token punctuation">\\</span><span class="token class-name">School</span><span class="token punctuation">.</span>students<span class="token punctuation">)</span> <span class="token keyword">var</span> school<span class="token punctuation">:</span> <span class="token class-name">School</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That can be optional or non-optional ‚Äì there are no safety constraints here, because you‚Äôre telling SwiftData exactly what you want.</p><p>Alternatively, we can change the <code>School</code> class so its <code>students</code> property looks like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Relationship</span><span class="token punctuation">(</span>inverse<span class="token punctuation">:</span> <span class="token punctuation">\\</span><span class="token class-name">Student</span><span class="token punctuation">.</span>school<span class="token punctuation">)</span> <span class="token keyword">var</span> students<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Student</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container important"><p class="hint-container-title">Important</p><p>Regardless of which option you choose, you should only specify the inverse relationship on one side. If you try specifying both, Xcode will throw up an error like ‚ÄúCircular reference resolving attached macro &#39;Relationship‚Äô.‚Äù</p></div><p>Using explicit relationships with the <code>@Relationship</code> macro is also useful for specifying a custom delete rule to control how linked objects are deleted. For example, if you removed a school from your database, should SwiftData also remove all its students?</p><div class="hint-container important"><p class="hint-container-title">Important</p><p>Remember, this is an issue of safety: by using an explicit relationship you‚Äôre taking responsibility for ensuring you keep your models in a valid state.</p></div><p>We have four delete rules in SwiftData, with <code>.nullify</code> being the default ‚Äì set the related model‚Äôs reference to nil when this object is deleted. If you have non-optional references ‚Äì if you say that all students must have exactly one school, for example ‚Äì then you should use a different delete rule instead.</p><p>For example, we might say that schools can have many students, and when we remove a student from our array we automatically delete that student object entirely. This uses the <code>.cascade</code> delete rule, like so:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@Model</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">School</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token attribute atrule">@Relationship</span><span class="token punctuation">(</span>deleteRule<span class="token punctuation">:</span> <span class="token punctuation">.</span>cascade<span class="token punctuation">,</span> inverse<span class="token punctuation">:</span> <span class="token punctuation">\\</span><span class="token class-name">Student</span><span class="token punctuation">.</span>school<span class="token punctuation">)</span> <span class="token keyword">var</span> students<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Student</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> students<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Student</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>students <span class="token operator">=</span> students</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If you‚Äôre still reading and aren‚Äôt sure whether to use implicit or explicit relationships, I‚Äôll give you a simple tip that has saved me so much time: I‚Äôve never regretted using an explicit relationship, so I always prefer to spell out what I mean rather than relying on SwiftData‚Äôs inference getting it right.</p>`,27);function w(o,y){const n=r("VPCard");return d(),l("div",null,[s("h1",h,[s("a",m,[s("span",null,p(o.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),a(n,e(t({title:"SwiftData by Example",desc:"Back to Home",link:"/hackingwithswift.com/swiftdata/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),k,v,a(n,e(t({title:"Inferred vs explicit relationships | SwiftData by Example",desc:"Inferred vs explicit relationships",link:"https://hackingwithswift.com/quick-start/swiftdata/inferred-vs-explicit-relationships",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),f])}const S=i(u,[["render",w],["__file","inferred-vs-explicit-relationships.html.vue"]]),x=JSON.parse('{"path":"/hackingwithswift.com/swiftdata/inferred-vs-explicit-relationships.html","title":"Inferred vs explicit relationships","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Inferred vs explicit relationships","description":"Article(s) > Inferred vs explicit relationships","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","swiftdata","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Inferred vs explicit relationships"},{"property":"og:description","content":"Inferred vs explicit relationships"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftdata/inferred-vs-explicit-relationships.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftdata/inferred-vs-explicit-relationships.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Inferred vs explicit relationships"}],["meta",{"property":"og:description","content":"Article(s) > Inferred vs explicit relationships"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftdata"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2023-09-30T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Inferred vs explicit relationships\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-30T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/hackingwithswift.com/swiftdata/how-to-index-swiftdata-properties-for-faster-searching.md","date":"2023-09-30T00:00:00.000Z","isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":3.35,"words":1006},"filePathRelative":"hackingwithswift.com/swiftdata/inferred-vs-explicit-relationships.md","localizedDate":"2023ÎÖÑ 9Ïõî 30Ïùº","excerpt":"\\n"}');export{S as comp,x as data};
