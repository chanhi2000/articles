import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as t,t as c,e as o,n as i,g as r,f as l,r as h,o as d}from"./app-BgNevrm5.js";const p={},w={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},m=t("nav",{class:"table-of-contents"},[t("ul")],-1),u=t("hr",null,null,-1),y=l("<blockquote><p>Updated for Xcode 15</p></blockquote><p>Every task can be created with a specific priority level, or it can inherit a priority from somewhere else. But in two specific circumstances, Swift will <em>raise</em> the priority of a task so it‚Äôs able to complete faster.</p><p>This always happens because of some specific action from us:</p><ol><li>If higher-priority task A starts waiting for the result of lower-priority task B, task B will have its priority elevated to the same priority as task A.</li><li>If lower-priority task A has started running on an actor, and higher-priority task B has been enqueued on that same actor, task A will have its priority elevated to match task B.</li></ol><p>In both cases, Swift is trying to ensure the higher priority task gets the quality of service it needs to run quickly ‚Äì if something very important can only complete when something less important is also complete, then the less important task <em>becomes</em> very important.</p><p>For the most part, this isn‚Äôt something we need to worry about in our code ‚Äì think of it as a bonus feature provided automatically by Swift‚Äôs tasks.</p><p>However, there is <em>one</em> place where priority escalation might surprise you, and it‚Äôs worth at least being aware of it: in our first situation, where a high-priority task uses <code>await</code> on a low-priority task, using <code>Task.currentPriority</code> will report the <em>escalated</em> priority rather than the original priority. So, you might create a task with a low priority, but when you query it a minute later it might have moved up to be a high priority.</p><p>At the time of writing, this is the only real ‚Äúgotcha‚Äù moment with task escalation. The other situation ‚Äì if you queue a high-priority task on the same actor where a low-priority task is already running ‚Äì will also involve priority escalation, but <em>won‚Äôt</em> change the value of <code>currentPriority</code>. This means your task will run a little faster and it might not be obvious why, but honestly it‚Äôs unlikely you‚Äôll even notice this.</p>",8),k={class:"hint-container details"},f=t("summary",null,"Similar solutions‚Ä¶",-1);function b(a,v){const e=h("VPCard");return d(),s("div",null,[t("h1",w,[t("a",g,[t("span",null,c(a.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),o(e,i(r({title:"Swift Concurrency by Example",desc:"Back to Home",link:"/hackingwithswift.com/concurrency/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),m,u,o(e,i(r({title:"Understanding how priority escalation works | Swift Concurrency by Example",desc:"Understanding how priority escalation works",link:"https://hackingwithswift.com/quick-start/concurrency/understanding-how-priority-escalation-works",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),y,t("details",k,[f,o(e,i(r({title:"How to control the priority of a task | Swift Concurrency by Example",desc:"How to control the priority of a task",link:"/hackingwithswift.com/concurrency/how-to-control-the-priority-of-a-task.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(e,i(r({title:"Understanding how global actor inference works | Swift Concurrency by Example",desc:"Understanding how global actor inference works",link:"/hackingwithswift.com/concurrency/understanding-how-global-actor-inference-works.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(e,i(r({title:"Understanding threads and queues | Swift Concurrency by Example",desc:"Understanding threads and queues",link:"/hackingwithswift.com/concurrency/understanding-threads-and-queues.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(e,i(r({title:"What‚Äôs the difference between a task and a detached task? | Swift Concurrency by Example",desc:"What‚Äôs the difference between a task and a detached task?",link:"/hackingwithswift.com/concurrency/whats-the-difference-between-a-task-and-a-detached-task.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),o(e,i(r({title:"How to run tasks using SwiftUI‚Äôs task() modifier | Swift Concurrency by Example",desc:"How to run tasks using SwiftUI‚Äôs task() modifier",link:"/hackingwithswift.com/concurrency/how-to-run-tasks-using-swiftuis-task-modifier.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16)])])}const U=n(p,[["render",b],["__file","understanding-how-priority-escalation-works.html.vue"]]),x=JSON.parse('{"path":"/hackingwithswift.com/concurrency/understanding-how-priority-escalation-works.html","title":"Understanding how priority escalation works","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Understanding how priority escalation works","description":"Article(s) > Understanding how priority escalation works","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Understanding how priority escalation works"},{"property":"og:description","content":"Understanding how priority escalation works"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/concurrency/understanding-how-priority-escalation-works.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/concurrency/understanding-how-priority-escalation-works.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Understanding how priority escalation works"}],["meta",{"property":"og:description","content":"Article(s) > Understanding how priority escalation works"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2021-07-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Understanding how priority escalation works\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-07-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"date":"2021-07-01T00:00:00.000Z","isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":2.25,"words":675},"filePathRelative":"hackingwithswift.com/concurrency/understanding-how-priority-escalation-works.md","localizedDate":"2021ÎÖÑ 7Ïõî 1Ïùº","excerpt":"\\n"}');export{U as comp,x as data};
