import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,b as t,t as d,e,n,g as a,d as i,a as h,f as g,r,o as u}from"./app-BgNevrm5.js";const m={},w={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},k=t("nav",{class:"table-of-contents"},[t("ul")],-1),b=t("hr",null,null,-1),v=t("blockquote",null,[t("p",null,"Available from Swift 5.0")],-1),y={href:"https://github.com/apple/swift-evolution/blob/master/proposals/0200-raw-string-escaping.md",target:"_blank",rel:"noopener noreferrer"},_=t("code",null,"apple/swift-evolution",-1),q=g(`<p>To use raw strings, place one or more <code>#</code> symbols before your strings, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> rain <span class="token operator">=</span> <span class="token string-literal"><span class="token string">#&quot;The &quot;rain&quot; in &quot;Spain&quot; falls mainly on the Spaniards.&quot;#</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The <code>#</code> symbols at the start and end of the string become part of the string delimiter, so Swift understands that the standalone quote marks around ‚Äúrain‚Äù and ‚ÄúSpain‚Äù should be treated as literal quote marks rather than ending the string.</p><p>Raw strings allow you to use backslashes too:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> keypaths <span class="token operator">=</span> <span class="token string-literal"><span class="token string">#&quot;Swift keypaths such as \\Person.name hold uninvoked references to properties.&quot;#</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That treats the backslash as being a literal character in the string, rather than an escape character. This in turn means that string interpolation works differently:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> answer <span class="token operator">=</span> <span class="token number">42</span></span>
<span class="line"><span class="token keyword">let</span> dontpanic <span class="token operator">=</span> <span class="token string-literal"><span class="token string">#&quot;The answer to life, the universe, and everything is </span><span class="token interpolation-punctuation punctuation">\\#(</span><span class="token interpolation">answer</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">.&quot;#</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Notice how I‚Äôve used <code>\\#(answer)</code> to use string interpolation ‚Äì a regular <code>\\(answer)</code> will be interpreted as characters in the string, so when you want string interpolation to happen in a raw string you must add the extra <code>#</code>.</p><p>One of the interesting features of Swift‚Äôs raw strings is the use of hash symbols at the start and end, because you can use more than one in the unlikely event you‚Äôll need to. It‚Äôs hard to provide a good example here because it really ought to be extremely rare, but consider this string: <strong>My dog said &quot;woof&quot;#gooddog</strong>. Because there‚Äôs no space before the hash, Swift will see <code>&quot;#</code> and immediately interpret it as the string terminator. In this situation we need to change our delimiter from <code>#&quot;</code> to <code>##&quot;</code>, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string-literal"><span class="token string">##&quot;My dog said &quot;woof&quot;#gooddog&quot;##</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Notice how the number of hashes at the end must match the number at the start.</p><p>Raw strings are fully compatible with Swift‚Äôs multi-line string system ‚Äì just use <code>#&quot;&quot;&quot;</code> to start, then <code>&quot;&quot;&quot;#</code> to end, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> multiline <span class="token operator">=</span> <span class="token string-literal"><span class="token string">#&quot;&quot;&quot;</span>
<span class="line">The answer to life,</span>
<span class="line">the universe,</span>
<span class="line">and everything is </span><span class="token interpolation-punctuation punctuation">\\#(</span><span class="token interpolation">answer</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">.</span>
<span class="line">&quot;&quot;&quot;#</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Being able to do without lots of backslashes will prove particularly useful in regular expressions. For example, writing a simple regex to find keypaths such as <code>\\Person.name</code> used to look like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> regex1 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;\\\\\\\\[A-Z]+[A-Za-z]+\\\\.[a-z]+&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Thanks to raw strings we can write the same thing with half the number of backslashes:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> regex2 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">#&quot;\\\\[A-Z]+[A-Za-z]+\\.[a-z]+&quot;#</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>We still need <em>some</em>, because regular expressions use them too.</p>`,18),S={class:"hint-container details"},x=t("summary",null,"Other Changes in Swift 5.0",-1),R={href:"https://hackingwithswift.com/files/playgrounds/swift/playground-4-2-to-5-0.playground.zip",target:"_blank",rel:"noopener noreferrer"};function C(l,T){const s=r("VPCard"),o=r("FontIcon");return u(),p("div",null,[t("h1",w,[t("a",f,[t("span",null,d(l.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),e(s,n(a({title:"HACKING WITH SWIFT",desc:"What's new in Swift?",link:"/hackingwithswift.com/swift/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),k,b,e(s,n(a({title:"Raw strings | Changes in Swift 5.0",desc:"Raw strings",link:"https://hackingwithswift.com/swift/5.0/raw-strings",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),v,t("p",null,[t("a",y,[i("SE-0200 ("),e(o,{icon:"iconfont icon-github"}),_,i(")")]),i(" added the ability to create raw strings, where backslashes and quote marks are interpreted as those literal symbols rather than escapes characters or string terminators. This makes a number of use cases more easy, but regular expressions in particular will benefit.")]),q,t("details",S,[x,h(` 
\`\`\`component VPCard
{
  "title": "Raw strings | Changes in Swift 5.0",
  "desc": "Raw strings",
  "link": "/hackingwithswift.com/swift/5.0/raw-strings.md",
  "logo": "https://hackingwithswift.com/favicon.svg",
  "background": "rgba(54,94,226,0.2)"
}
\`\`\`
`),e(s,n(a({title:"A standard Result type | Changes in Swift 5.0",desc:"A standard Result type",link:"/hackingwithswift.com/swift/5.0/result.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e(s,n(a({title:"Customizing string interpolation | Changes in Swift 5.0",desc:"Customizing string interpolation",link:"/hackingwithswift.com/swift/5.0/string-interpolation.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e(s,n(a({title:"Dynamically callable types | Changes in Swift 5.0",desc:"Dynamically callable types",link:"/hackingwithswift.com/swift/5.0/dynamically-callable-types.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e(s,n(a({title:"Handling future enum cases | Changes in Swift 5.0",desc:"Handling future enum cases",link:"/hackingwithswift.com/swift/5.0/handling-future-enum-cases.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e(s,n(a({title:"Flattening nested optionals resulting from try? | Changes in Swift 5.0",desc:"Flattening nested optionals resulting from try?",link:"/hackingwithswift.com/swift/5.0/flattening-optionals.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e(s,n(a({title:"Checking for integer multiples | Changes in Swift 5.0",desc:"Checking for integer multiples",link:"/hackingwithswift.com/swift/5.0/integer-multiples.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e(s,n(a({title:"Transforming and unwrapping dictionary values with compactMapValues() | Changes in Swift 5.0",desc:"Transforming and unwrapping dictionary values with compactMapValues()",link:"/hackingwithswift.com/swift/5.0/compactmapvalues.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t("p",null,[t("a",R,[e(o,{icon:"fas fa-file-zipper"}),i("Download Swift 5.0 playground")])])])])}const V=c(m,[["render",C],["__file","raw-strings.html.vue"]]),j=JSON.parse('{"path":"/hackingwithswift.com/swift/5.0/raw-strings.html","title":"Raw strings","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Raw strings","description":"Article(s) > Raw strings","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","swift","swift-5.0"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Raw strings"},{"property":"og:description","content":"Raw strings"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/5.0/raw-strings.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/5.0/raw-strings.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Raw strings"}],["meta",{"property":"og:description","content":"Article(s) > Raw strings"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swift-5.0"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Raw strings\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/hackingwithswift.com/swift/5.1/creating-uninitialized-arrays.md","isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":2.72,"words":815},"filePathRelative":"hackingwithswift.com/swift/5.0/raw-strings.md","excerpt":"\\n"}');export{V as comp,j as data};
