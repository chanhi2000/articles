import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,b as s,t as u,e as n,n as i,g as l,d as a,f as t,r as p,o as h}from"./app-BgNevrm5.js";const k={},m={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},w=s("nav",{class:"table-of-contents"},[s("ul")],-1),f=s("hr",null,null,-1),v=t(`<p>The next step in our project is to get our app working a little bit, which means writing a method that loads the input text and splits it up into words. Sticking with TDD for now, this means we first need to write a test that fails before updating our code to fix it.</p><p>Right now we&#39;re checking <code>allWords</code> contains 0 items, which needs to change: there are in fact 384,001 words in the input text (based on the character splitting criteria we&#39;ll get to shortly), so please update your <code>testAllWordsLoaded()</code> method to this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token class-name">XCTAssertEqual</span><span class="token punctuation">(</span>playData<span class="token punctuation">.</span>allWords<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token number">384001</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;allWords was not 384001&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>This number, 384,001, is of course entirely arbitrary because it depends on the input data. But that&#39;s not the point: we need to tell XCTest what &quot;correct&quot; looks like, because it has no way of knowing what constitutes a pass or a fail unless we give it specific criteria.</p><p>If you click the green checkmark next to the test now, it will be run again and will fail this time because we haven&#39;t written the loading code â€“ XCTest expects <code>allWords</code> to contain 384,001 strings, but it contains 0. This is good, honest!</p><figure><img src="https://hackingwithswift.com/img/books/hws/39-5@2x.png" alt="Our tests are now failing, which is a core part of test-driven development: write tests that fail, then write the code that makes those tests pass." tabindex="0" loading="lazy"><figcaption>Our tests are now failing, which is a core part of test-driven development: write tests that fail, then write the code that makes those tests pass.</figcaption></figure><p>Let&#39;s put testing to one side for now and fill in some of our program â€“ we&#39;ll be back with the testing soon enough, don&#39;t worry.</p>`,7),b=s("code",null,"PlayData.swift",-1),y=t(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token class-name">Bundle</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span>forResource<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;plays&quot;</span></span><span class="token punctuation">,</span> ofType<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;txt&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token keyword">let</span> plays <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token class-name">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            allWords <span class="token operator">=</span> plays<span class="token punctuation">.</span><span class="token function">components</span><span class="token punctuation">(</span>separatedBy<span class="token punctuation">:</span> <span class="token class-name">CharacterSet</span><span class="token punctuation">.</span>alphanumerics<span class="token punctuation">.</span>inverted<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The only new line there is the one that sets <code>allWords</code>, which uses two new things at once. Previously we used <code>components(separatedBy:)</code> to convert a string into an array, but this time the method is different because we pass in a character set rather than string. This new method splits a string by any number of characters rather than a single string, which is important because we want to split on periods, question marks, exclamation marks, quote marks and more.</p><p>There are a number of ways of specifying character sets, including a helpful <code>CharacterSet(charactersIn:)</code> initializer that we could have used to specify the full list of characters we want to break on. But the simplest approach is to split on anything that isn&#39;t a letter or number, which can be achieved by inverting the alphanumeric character set as seen in the code.</p>`,3),x=s("code",null,"ViewController.swift",-1),S=t(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">var</span> playData <span class="token operator">=</span> <span class="token class-name">PlayData</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That gives the <code>ViewController</code> class its own <code>PlayData</code> object to work with. That one line also creates the object immediately, which in turn will call the <code>init()</code> method we just wrote to load the word data â€“ not bad for a single line of code!</p><p>All that&#39;s left in this step is to add the basic table view code to show some cells. Please add these two methods to <code>ViewController</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function-definition function">tableView</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> tableView<span class="token punctuation">:</span> <span class="token class-name">UITableView</span><span class="token punctuation">,</span> numberOfRowsInSection section<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> playData<span class="token punctuation">.</span>allWords<span class="token punctuation">.</span>count</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function-definition function">tableView</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> tableView<span class="token punctuation">:</span> <span class="token class-name">UITableView</span><span class="token punctuation">,</span> cellForRowAt indexPath<span class="token punctuation">:</span> <span class="token class-name">IndexPath</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">UITableViewCell</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> cell <span class="token operator">=</span> tableView<span class="token punctuation">.</span><span class="token function">dequeueReusableCell</span><span class="token punctuation">(</span>withIdentifier<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Cell&quot;</span></span><span class="token punctuation">,</span> <span class="token keyword">for</span><span class="token punctuation">:</span> indexPath<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> word <span class="token operator">=</span> playData<span class="token punctuation">.</span>allWords<span class="token punctuation">[</span>indexPath<span class="token punctuation">.</span>row<span class="token punctuation">]</span></span>
<span class="line">    cell<span class="token punctuation">.</span>textLabel<span class="token operator">!</span><span class="token punctuation">.</span>text <span class="token operator">=</span> word</span>
<span class="line">    <span class="token keyword">return</span> cell</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There is nothing new there, so I hope it posed no challenge for you.</p><p>Press <kbd>Cmd</kbd>+<kbd>R</kbd> to run the app and you&#39;ll see a long table full of words â€“ it works! It&#39;s a long way from perfect, though: it&#39;s breaking on apostrophes (so ALL and S are on different lines), there are blank lines, there are duplicate words (the I after ACT and SCENE is repeated), and the detail text label just says &quot;Detail&quot; again and again.</p><figure><img src="https://hackingwithswift.com/img/books/hws/39-6@2x.png" alt="The results so far: word splitting works fine, but all those empty lines aren&#39;t great, and the detail text label needs to be fixed." tabindex="0" loading="lazy"><figcaption>The results so far: word splitting works fine, but all those empty lines aren&#39;t great, and the detail text label needs to be fixed.</figcaption></figure><p>We&#39;re going to fix all those except the first one, which is a text issue rather than a coding issue. In fact, we need to fix the second one straight away because my calculation of 384,001 words excludes empty strings â€“ we need to modify our <code>init()</code> method so that empty strings are removed if we want our test to pass.</p><p>As promised, I&#39;m going to use this project to teach you a little bit of functional programming, in particular the <code>filter()</code> method. This creates a new array from an existing one, selecting from it only items that match a function you provide. Stick with me for a moment, because this is important: a function that accepts a function as a parameter, like <code>filter()</code>, is called a <em>higher-order function</em>, and allows you to write extremely concise, expressive code that is efficient to run.</p><p>Let&#39;s take a look at <code>filter()</code> now. Please add this to <code>init()</code>, just after the call to <code>components(separatedBy:)</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That one line is all it takes to remove empty lines from the <code>allWords</code> array. However, this syntax can look like line noise if you&#39;re new to Swift, so I want to deconstruct what it does by first rewriting that code in a way you&#39;re more familiar with. I don&#39;t want you to put any of this into your code â€“ this is just to help you understand what&#39;s going on.</p><p>Here is that one line written out more verbosely:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">(</span>testString<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token keyword">in</span></span>
<span class="line">    <span class="token keyword">if</span> testString <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In that form, you can see that <code>filter()</code> is a method that takes a single parameter, which is a closure. That closure must accept a string, named <code>testString</code>, and return a <code>Bool</code>. The code then checks whether <code>testString</code> is empty or not, and returns either true or false.</p><p>Swift lives up to its name not only in that Swift code executes quickly, but it&#39;s also quick to write. So, there are a few shortcuts it offers to help reduce that long code down in size. For example, all that <code>(testString: String) -&gt; Bool</code> definition isn&#39;t really needed: Swift can see that <code>filter()</code> wants a closure that accepts a string and returns true or false, so we don&#39;t need to repeat ourselves. So, let&#39;s take it out:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> testString <span class="token keyword">in</span></span>
<span class="line">    <span class="token keyword">if</span> testString <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Next, we can collapse that <code>if/else</code> block into one line of code: <code>return testString != &quot;&quot;</code>.</p><p>When Swift runs <code>testString != &quot;&quot;</code> it will either find that statement to be true (yes, <code>testString</code> is not empty) or false (no, <code>testString</code> is empty), and pass that straight to <code>return</code>. So, this will return true if <code>testString</code> has any text, which is exactly what we want.</p><p>With that change, here&#39;s the code now:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> testString <span class="token keyword">in</span></span>
<span class="line">    <span class="token keyword">return</span> testString <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Moving on, we can take advantage of Swift&#39;s trailing closure syntax, because <code>filter()</code>&#39;s only parameter is a closure. If you remember, that means the parentheses aren&#39;t needed. So, the code can become this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> testString <span class="token keyword">in</span></span>
<span class="line">    <span class="token keyword">return</span> testString <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Next, if your closure has only one expression â€“ which ours does â€“ and the closure must return a value, Swift lets you omit the <code>return</code> keyword entirely. This is because it knows the closure must return a value, and it can see you&#39;re only providing one line of code, so that must be the one that returns something. So, you can write this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> testString <span class="token keyword">in</span></span>
<span class="line">    testString <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And now for the bit that usually confuses people: shorthand parameter names. When you use a closure like this, Swift automatically creates anonymous parameter names that start with a dollar sign then have a number: <code>$0</code>, <code>$1</code>, <code>$2</code>, <code>$3</code> and so on. This unique naming really helps them stand out, so if you see them in code you immediately know they are shorthand parameter names â€“ you literally cannot use names like this yourself, so they only have one meaning.</p><p>Swift gives you one of these shorthand parameters for every parameter that your closure accepts. In this case, our filter closure accepts exactly one parameter, which is <code>testString</code>. If we want to use Swift&#39;s shorthand parameter names instead, we don&#39;t need <code>testString</code> any more because <code>testString</code> and <code>$0</code>, so that whole <code>testString in</code> part can go away:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span>filter <span class="token punctuation">{</span></span>
<span class="line">    <span class="token short-argument">$0</span> <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now all that&#39;s left is to put that on a single line, and we&#39;re done:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">allWords <span class="token operator">=</span> allWords<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">!=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Now, even though I&#39;ve explained the thinning process that goes from long code to tiny code, you might still look at that one line and find it confusing. That&#39;s OK: you should write code however you want to write code. But in this instance, I hope you&#39;ll agree that having one simple, clutter-free line of code is easier to read, understand, and maintain than five or six lines.</p><p>Now that empty lines are being stripped out, you should be able to return back to <code>testAllWordsLoaded()</code> and have it pass.</p><figure><img src="https://hackingwithswift.com/img/books/hws/39-7@2x.png" alt="With blank lines removed this app is almost starting to look useful!" tabindex="0" loading="lazy"><figcaption>With blank lines removed this app is almost starting to look useful!</figcaption></figure>`,33);function q(c,_){const e=p("VPCard"),o=p("FontIcon");return h(),d("div",null,[s("h1",m,[s("a",g,[s("span",null,u(c.$frontmatter.title)+" ê´€ë ¨",1)])]),n(e,i(l({title:"Hacking with iOS â€“ learn to code iPhone and iPad apps with free Swift tutorials",desc:"Learn Swift coding for iOS with these free tutorials â€“ learn Swift, iOS, and Xcode",link:"/hackingwithswift.com/read/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),w,f,n(e,i(l({title:"Loading our data and splitting up words: filter() | Hacking with iOS",desc:"Loading our data and splitting up words: filter()",link:"https://hackingwithswift.com/read/39/3/loading-our-data-and-splitting-up-words-filter",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),v,s("p",null,[a("Add this to "),n(o,{icon:"fa-brands fa-swift"}),b,a(":")]),y,s("p",null,[a("That's all it takes to load enough data for us to move on with, but we can't tell that it works unless we also update the user interface to show our data. So, open "),n(o,{icon:"fa-brands fa-swift"}),x,a(" and add this property:")]),S])}const I=r(k,[["render",q],["__file","03-loading-our-data-and-splitting-up-words-filter.html.vue"]]),j=JSON.parse('{"path":"/hackingwithswift.com/read/39/03-loading-our-data-and-splitting-up-words-filter.html","title":"Loading our data and splitting up words: filter()","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Loading our data and splitting up words: filter()","description":"Article(s) > Loading our data and splitting up words: filter()","category":["Swift","iOS","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","xcode","appstore","ios"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Loading our data and splitting up words: filter()"},{"property":"og:description","content":"Loading our data and splitting up words: filter()"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/read/39/03-loading-our-data-and-splitting-up-words-filter.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/read/39/03-loading-our-data-and-splitting-up-words-filter.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Loading our data and splitting up words: filter()"}],["meta",{"property":"og:description","content":"Article(s) > Loading our data and splitting up words: filter()"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://hackingwithswift.com/img/books/hws/39-5@2x.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:tag","content":"ios"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Loading our data and splitting up words: filter()\\",\\"image\\":[\\"https://hackingwithswift.com/img/books/hws/39-5@2x.png\\",\\"https://hackingwithswift.com/img/books/hws/39-6@2x.png\\",\\"https://hackingwithswift.com/img/books/hws/39-7@2x.png\\"],\\"dateModified\\":null,\\"author\\":[]}"]],"isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":5.82,"words":1747},"filePathRelative":"hackingwithswift.com/read/39/03-loading-our-data-and-splitting-up-words-filter.md","excerpt":"\\n"}');export{I as comp,j as data};
