import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,b as e,t as h,e as t,n as s,g as n,d,f as i,r as o,o as u}from"./app-BgNevrm5.js";const m={},w={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},y=e("nav",{class:"table-of-contents"},[e("ul")],-1),k=e("hr",null,null,-1),g=i(`<blockquote><p>Updated for Xcode 15</p></blockquote><p>Swift‚Äôs actors are conceptually like classes that are safe to use in concurrent environments. This safety is made possible because Swift automatically ensures no two pieces of code attempt to access an actor‚Äôs data at the same time ‚Äì it is made impossible by the compiler, rather than requiring developers to write boilerplate code using systems such as locks.</p><p>In the following chapters we‚Äôre going to explore more about how actors work and when you should use them, but here is the least you need to know:</p><ol><li>Actors are created using the <code>actor</code> keyword. This is a concrete nominal type in Swift, like structs, classes, and enums.</li><li>Like classes, actors are reference types. This makes them useful for sharing state in your program.</li><li>They have many of the same features as classes: you can give them properties, methods (async or otherwise), initializers, and subscripts, they can conform to protocols, and they can be generic.</li><li>Actors do not support inheritance, so they cannot have convenience initializers, and do not support either <code>final</code> or <code>override</code>.</li><li>All actors automatically conform to the <code>Actor</code> protocol, which no other type can use. This allows you to write code restricted to work only with actors.</li></ol><p>As well as those, there is one more behavior of actors that lies at the center of their existence: if you‚Äôre attempting to read a variable property or call a method on an actor, and you‚Äôre doing it from outside the actor itself, you must do so asynchronously using <code>await</code>.</p><p>I‚Äôll explain why in a moment, but I want to show you a brief snippet of code first so you can see what I mean:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">actor</span> <span class="token class-name">User</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> score <span class="token operator">=</span> <span class="token number">10</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">printScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;My score is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">score</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">copyScore</span><span class="token punctuation">(</span>from other<span class="token punctuation">:</span> <span class="token class-name">User</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span></span>
<span class="line">        score <span class="token operator">=</span> <span class="token keyword">await</span> other<span class="token punctuation">.</span>score</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> actor1 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> actor2 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span>actor1<span class="token punctuation">.</span>score<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">await</span> actor1<span class="token punctuation">.</span><span class="token function">copyScore</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> actor2<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),b={href:"https://hackingwithswift.com/files/projects/concurrency/what-is-an-actor-and-why-does-swift-have-them-1.zip",target:"_blank",rel:"noopener noreferrer"},v=i('<p>You can see several things in action there:</p><ol><li>The new <code>User</code> type is created using the <code>actor</code> keyword rather than <code>struct</code> or <code>class</code>.</li><li>It can have properties and methods just like structs or classes.</li><li>The <code>printScore()</code> method can access the local <code>score</code> property just fine, because it‚Äôs our actor‚Äôs method reading its own property.</li><li>But in <code>copyScore(from:)</code> we‚Äôre attempting to read the score from another user, and we can‚Äôt read their <code>score</code> property without marking the request with <code>await</code>.</li><li>Code from <em>outside</em> the actor also needs to use <code>await</code>.</li></ol><p>The reason the <code>await</code> call is needed in <code>copyScore(from:)</code> is central to the reasons actors are needed at all. You see, rather than just letting us poke around in an actor‚Äôs mutable state, Swift silently translates that request into what is effectively a message that goes into the actor‚Äôs message inbox: ‚Äúplease let me know your score as soon as you can.‚Äù</p><p>If the actor is currently idle it can respond with the score straight away and our code continues no different from if we had used a class or a struct. But the actor might also have multiple other messages waiting in its inbox that it needs to deal with first, so our <code>score</code> request has to wait. Eventually our request makes it to the top of the inbox and it will be dealt with, and the <code>copyScore(from:)</code> method will continue.</p><p>This means several things:</p><ol><li>Actors are effectively operating a private serial queue for their message inbox, taking requests one at a time and fulfilling them. This executes requests in the order they were received, but you can also use task priority to escalate requests.</li><li>Only one piece of code at a time can access an actor‚Äôs mutable state unless you specifically mark some things as being unprotected. Swift calls this <em>actor isolation</em>.</li><li>Just like regular <code>await</code> calls, reading an actor‚Äôs property or method marks a potential suspension point ‚Äì we might get a value back immediately, but it might also take a little time.</li><li>Any state that is <em>not</em> mutable ‚Äì i.e., a constant property ‚Äì can be accessed without <code>await</code>, because it‚Äôs always going to be safe.</li></ol><p>In practice, the rule to remember is this: if you are writing code inside an actor‚Äôs method, you can read other properties on that actor and call its synchronous methods without using <code>await</code>, but if you‚Äôre trying to use that data from <em>outside</em> the actor <code>await</code> is required even for synchronous properties and methods. Think of situations where using <code>self</code> is possible: if you could <code>self</code> you don‚Äôt need <code>await</code>.</p><p><strong>Writing properties from outside an actor is not allowed, with or without <code>await</code>.</strong></p><p>Of course, the real question here is why Swift needs actors at all ‚Äì what‚Äôs their fundamental purpose? And the answer is straightforward: if you ever need to make sure that access to some object is restricted to a single task at a time, actors are perfect.</p><p>This is more common than you might think ‚Äì yes, UI work should be restricted to the main thread, but you probably also want to restrict database access so that you can‚Äôt write conflicting data, for example. There are also times when simultaneous concurrent access to data can cause <em>data races</em> ‚Äì when the outcome of your work depends on the order in which tasks complete. These errors are particularly nasty to find and fix, but with actors such data races become impossible.</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>Creating an instance of an actor has no extra performance cost compared to creating an instance of a class; the only performance difference comes when trying to access the protected state of an actor, which might trigger task suspension.</p></div>',11),S={class:"hint-container details"},_=e("summary",null,"Similar solutions‚Ä¶",-1);function x(c,T){const a=o("VPCard"),r=o("FontIcon");return u(),p("div",null,[e("h1",w,[e("a",f,[e("span",null,h(c.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),t(a,s(n({title:"Swift Concurrency by Example",desc:"Back to Home",link:"/hackingwithswift.com/concurrency/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),y,k,t(a,s(n({title:"What is an actor and why does Swift have them? | Swift Concurrency by Example",desc:"What is an actor and why does Swift have them?",link:"https://hackingwithswift.com/quick-start/what-is-an-actor-and-why-does-swift-have-them",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),g,e("blockquote",null,[e("p",null,[e("a",b,[t(r,{icon:"fas fa-file-zipper"}),d("Download this as an Xcode project")])])]),v,e("details",S,[_,t(a,s(n({title:"How to create and use an actor in Swift | Swift Concurrency by Example",desc:"How to create and use an actor in Swift",link:"/hackingwithswift.com/concurrency/how-to-create-and-use-an-actor-in-swift.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,s(n({title:"What is actor hopping and how can it cause problems? | Swift Concurrency by Example",desc:"What is actor hopping and how can it cause problems?",link:"/hackingwithswift.com/concurrency/what-is-actor-hopping-and-how-can-it-cause-problems.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,s(n({title:"How to make parts of an actor nonisolated | Swift Concurrency by Example",desc:"How to make parts of an actor nonisolated",link:"/hackingwithswift.com/concurrency/how-to-make-parts-of-an-actor-nonisolated.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,s(n({title:"Understanding how global actor inference works | Swift Concurrency by Example",desc:"Understanding how global actor inference works",link:"/hackingwithswift.com/concurrency/understanding-how-global-actor-inference-works.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(a,s(n({title:"What‚Äôs the difference between a task and a detached task? | Swift Concurrency by Example",desc:"What‚Äôs the difference between a task and a detached task?",link:"/hackingwithswift.com/concurrency/whats-the-difference-between-a-task-and-a-detached-task.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16)])])}const W=l(m,[["render",x],["__file","what-is-an-actor-and-why-does-swift-have-them.html.vue"]]),C=JSON.parse('{"path":"/hackingwithswift.com/concurrency/what-is-an-actor-and-why-does-swift-have-them.html","title":"What is an actor and why does Swift have them?","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"What is an actor and why does Swift have them?","description":"Article(s) > What is an actor and why does Swift have them?","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > What is an actor and why does Swift have them?"},{"property":"og:description","content":"What is an actor and why does Swift have them?"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/what-is-an-actor-and-why-does-swift-have-them.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/concurrency/what-is-an-actor-and-why-does-swift-have-them.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"What is an actor and why does Swift have them?"}],["meta",{"property":"og:description","content":"Article(s) > What is an actor and why does Swift have them?"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2021-11-28T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"What is an actor and why does Swift have them?\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-11-28T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/hackingwithswift.com/concurrency/is-it-efficient-to-create-many-tasks.md","date":"2021-11-28T00:00:00.000Z","isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":4.62,"words":1385},"filePathRelative":"hackingwithswift.com/concurrency/what-is-an-actor-and-why-does-swift-have-them.md","localizedDate":"2021ÎÖÑ 11Ïõî 28Ïùº","excerpt":"\\n"}');export{W as comp,C as data};
