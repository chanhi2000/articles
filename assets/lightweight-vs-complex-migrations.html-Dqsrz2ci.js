import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as t,t as s,e as i,n as o,g as a,f as c,r as h,o as g}from"./app-BgNevrm5.js";const m={},p={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},d={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},u=t("nav",{class:"table-of-contents"},[t("ul")],-1),w=t("hr",null,null,-1),f=c('<blockquote><p>Updated for Xcode 15</p></blockquote><p>When you change your data model, SwiftData can sometimes handle the update automatically, but often it needs intervention from you to make sure the update goes smoothly. This is known as <em>data migration</em>, and in SwiftData we call automatic migration ‚Äúlightweight‚Äù, and everything else ‚Äúcomplex‚Äù. You‚Äôll need to know how both work if you intend to change your data model over time.</p><p>SwiftData will execute lightweight migration automatically for a range of small changes, including:</p><ol><li>Adding one or more new models.</li><li>Adding one or more new properties that have a default value.</li><li>Renaming one or more properties.</li><li>Deleting properties from a model.</li><li>Adding or removing the <code>.externalStorage</code> or <code>.allowsCloudEncryption</code> attributes.</li><li>Adding the <code>.unique</code> attribute and all values for that property are already unique.</li><li>Adjusting the delete rule on relationships.</li></ol><p>These changes are always safe, and so are automatic. In contrast, changes that <em>aren‚Äôt</em> safe will require a complex migration where you need to step in and handle the update yourself.</p><p>For example, if you‚Äôre adding the <code>.unique</code> attribute to a property where all values for that property are already unique, it‚Äôs a lightweight migration. But if there are duplicate values the lightweight migration will fail, and your container will not be loaded ‚Äì your app will effectively be non-functional.</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>Broadly speaking it‚Äôs a good idea to tell SwiftData about all migrations that might happen in your app, even if they are all lightweight, because it makes life easier if you introduce more complex migrations in the future.</p></div>',7);function y(n,v){const e=h("VPCard");return g(),l("div",null,[t("h1",p,[t("a",d,[t("span",null,s(n.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),i(e,o(a({title:"SwiftData by Example",desc:"Back to Home",link:"/hackingwithswift.com/swiftdata/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),u,w,i(e,o(a({title:"Lightweight vs complex migrations | SwiftData by Example",desc:"Lightweight vs complex migrations",link:"https://hackingwithswift.com/quick-start/swiftdata/lightweight-vs-complex-migrations",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),f])}const b=r(m,[["render",y],["__file","lightweight-vs-complex-migrations.html.vue"]]),_=JSON.parse('{"path":"/hackingwithswift.com/swiftdata/lightweight-vs-complex-migrations.html","title":"Lightweight vs complex migrations","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Lightweight vs complex migrations","description":"Article(s) > Lightweight vs complex migrations","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","swiftdata","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Lightweight vs complex migrations"},{"property":"og:description","content":"Lightweight vs complex migrations"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftdata/lightweight-vs-complex-migrations.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swiftdata/lightweight-vs-complex-migrations.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Lightweight vs complex migrations"}],["meta",{"property":"og:description","content":"Article(s) > Lightweight vs complex migrations"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftdata"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2024-04-16T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lightweight vs complex migrations\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-16T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/hackingwithswift.com/swiftdata/how-to-rollback-changes-without-saving.md","date":"2024-04-16T00:00:00.000Z","isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":1.29,"words":388},"filePathRelative":"hackingwithswift.com/swiftdata/lightweight-vs-complex-migrations.md","localizedDate":"2024ÎÖÑ 4Ïõî 16Ïùº","excerpt":"\\n"}');export{b as comp,_ as data};
