import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,b as e,t as u,e as n,n as t,g as a,d as i,a as d,f as h,r as c,o as m}from"./app-BgNevrm5.js";const g={},f={id:"frontmatter-title-관련",tabindex:"-1"},w={class:"header-anchor",href:"#frontmatter-title-관련"},k=e("nav",{class:"table-of-contents"},[e("ul")],-1),b=e("hr",null,null,-1),y=e("blockquote",null,[e("p",null,"Available from Swift 5.1")],-1),v={href:"https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md",target:"_blank",rel:"noopener noreferrer"},q=e("code",null,"apple/swift-evolution",-1),S=h(`<p>At first glance that sounds a lot like a protocol, but opaque return types take the concept of protocols significantly further because are able to work with associated types, they require the same type to be used internally each time, and they allow us to hide implementation details.</p><p>As an example, if we wanted to launch different kinds of fighters from a Rebel base we might write code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Fighter</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">XWing</span><span class="token punctuation">:</span> <span class="token class-name">Fighter</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">launchFighter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Fighter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">XWing</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> red5 <span class="token operator">=</span> <span class="token function">launchFighter</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Whoever calls that function knows it will return some sort of <code>Fighter</code> but doesn’t know precisely what. As a result, we could add <code>struct YWing: Fighter { }</code> or other types, and have any of them be returned.</p><p>But there’s a problem: what if we wanted to check whether a specific fighter was Red 5? You <em>might</em> think the solution is to make <code>Fighter</code> conform to the <code>Equatable</code> protocol so we can use <code>==</code>. However, as soon as you do that Swift will throw up a particularly dreaded error for the <code>launchFighter</code> function: “Protocol &#39;Fighter&#39; can only be used as a generic constraint because it has Self or associated type requirements.”</p><p>The “Self” part of that error is what is hitting us here. The <code>Equatable</code> protocol has to compare two instances of itself (“Self”) to see whether they are the same, but Swift has no guarantee that the two equatable things are remotely the same – we could be comparing a Fighter with an array of integers, for example.</p><p>Opaque types solve this problem because even though <em>we</em> just see a protocol being used, internally the Swift compiler knows exactly what that protocol actually resolves to – it knows it’s an <code>XWing</code>, an array of strings, or whatever.</p><p>To send back an opaque type, use the keyword <code>some</code> before your protocol name:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">launchOpaqueFighter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Fighter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">XWing</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>From the caller’s perspective that still gets back a <code>Fighter</code>, which might be an <code>XWing</code>, a <code>YWing</code>, or something else that conforms to the <code>Fighter</code> protocol. But from the <em>compiler’s</em> perspective it knows exactly what is being returned, so it can make sure we follow all the rules correctly.</p><p>For example, consider a function that returned <code>some Equatable</code> like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">makeInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Int</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">10</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When we call that, all we know is that it is some sort of <code>Equatable</code> value, however if call it twice then we can compare the results of those two calls because Swift knows for sure it will be the same underlying type:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> int1 <span class="token operator">=</span> <span class="token function">makeInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> int2 <span class="token operator">=</span> <span class="token function">makeInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>int1 <span class="token operator">==</span> int2<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The same is <em>not</em> true if we had a <em>second</em> function that returned <code>some Equatable</code>, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">makeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token string-literal"><span class="token string">&quot;Red&quot;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Even though from our perspective both send us back an <code>Equatable</code> type, and we <em>can</em> compare the results of two calls to <code>makeString()</code> or two calls to <code>makeInt()</code>, Swift won’t let us compare the return value of <code>makeString()</code> to the return value of <code>makeInt()</code> because it knows comparing a string and an integer doesn’t make any sense.</p><p>An important proviso here is that functions with opaque return types must always return one specific type. If for example we tried to use <code>Bool.random()</code> to randomly launch an <code>XWing</code> or a <code>YWing</code> then Swift would refuse to build our code because the compiler can no longer tell what will be sent back.</p><p>You might well think “if we always need to return the same type, why not just write the function as <code>func launchFighter() -&gt; XWing</code>? While that might work sometimes, it creates new problems such as:</p><ul><li>We end up with types we don’t really want to expose to the world. For example, if we used <code>someArray.lazy.drop { … }</code> we get sent back a <code>LazyDropWhileSequence</code> – a dedicated and highly specific type from the Swift standard library. All we actually care about is that this thing is a sequence; we don’t need to know how Swift’s internals work.</li><li>We lose the ability to change our mind later. Making <code>launchFighter()</code> return only an <code>XWing</code> means we can’t switch to a different type in the future, and given how much Disney relies on Star Wars toy sales that would be a problem! By returning an opaque type we can return X-Wings today, then move to B-Wings in a year – we only ever return one in any given build of our code, but we can still have the flexibility to change our mind.</li></ul><p>In some respects all this might sound similar to generics, which also solve the “Self or associated type requirements” problem. Generics allow us to write code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">ImperialFighter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">TIEFighter</span><span class="token punctuation">:</span> <span class="token class-name">ImperialFighter</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">TIEAdvanced</span><span class="token punctuation">:</span> <span class="token class-name">ImperialFighter</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">launchImperialFighter</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">ImperialFighter</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That defines a new protocol that requires conforming types to be initializable with no parameters, defines two structs that conform to that protocol, then creates a generic function to use it. However, the difference here is that now <em>callers</em> of <code>launchImperialFighter()</code> are the ones to choose what kind of fighter they get, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> fighter1<span class="token punctuation">:</span> <span class="token class-name">TIEFighter</span> <span class="token operator">=</span> <span class="token function">launchImperialFighter</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> fighter2<span class="token punctuation">:</span> <span class="token class-name">TIEAdvanced</span> <span class="token operator">=</span> <span class="token function">launchImperialFighter</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>If you <em>want</em> callers to be able to select their data type then generics work well, but if you want the <em>function</em> to decide the return type then they fall down;</p><p>So, opaque result types allow us to do several things:</p><ul><li>Our functions decide what type of data gets returned, not the caller of those functions.</li><li>We don’t need to worry about Self or associated type requirements, because the compiler knows exactly what type is inside.</li><li>We get to change our minds in the future whenever we need to.</li><li>We don’t expose private internal types to the outside world.</li></ul><p>If you ever forget the difference between protocols and opaque types, think of this: returning <code>Fighter</code> means &quot;any sort of <code>Fighter</code> type but we don&#39;t know what&quot;, whereas returning <code>some Fighter</code> means &quot;a specific sort of <code>Fighter</code> type but we still don&#39;t know what.&quot; In the latter case, the difference is that the underlying type is something specific that the compiler knows about, whereas in the former case it can literally be anything that conforms to the protocol – even being different every time we call the method.</p>`,28),_={class:"hint-container details"},F=e("summary",null,"Other Changes in Swift 5.1",-1),I={href:"https://hackingwithswift.com/files/playgrounds/swift/playground-5-0-to-5-1.playground.zip",target:"_blank",rel:"noopener noreferrer"};function W(l,x){const s=c("VPCard"),o=c("FontIcon");return m(),r("div",null,[e("h1",f,[e("a",w,[e("span",null,u(l.$frontmatter.title)+" 관련",1)])]),n(s,t(a({title:"HACKING WITH SWIFT",desc:"What's new in Swift?",link:"/hackingwithswift.com/swift/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),k,b,n(s,t(a({title:"Opaque return types | Changes in Swift 5.1",desc:"Opaque return types",link:"https://hackingwithswift.com/swift/5.1/opaque-return-types",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),y,e("p",null,[e("a",v,[i("SE-0244 ("),n(o,{icon:"iconfont icon-github"}),q,i(")")]),i(" introduced the concept of opaque types into Swift. An opaque type is one where we’re told about the capabilities of an object without knowing specifically what kind of object it is.")]),S,e("details",_,[F,n(s,t(a({title:"Improvements to synthesized memberwise initializers | Changes in Swift 5.1",desc:"Improvements to synthesized memberwise initializers",link:"/hackingwithswift.com/swift/5.1/improved-memberwise-initializers.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n(s,t(a({title:"Implicit returns from single-expression functions | Changes in Swift 5.1",desc:"Implicit returns from single-expression functions",link:"/hackingwithswift.com/swift/5.1/implicit-returns.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n(s,t(a({title:"Universal Self | Changes in Swift 5.1",desc:"Universal Self",link:"/hackingwithswift.com/swift/5.1/universal-self.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),d(` 
\`\`\`component VPCard
{
  "title": "Opaque return types | Changes in Swift 5.1",
  "desc": "Opaque return types",
  "link": "/hackingwithswift.com/swift/5.1/opaque-return-types.md",
  "logo": "https://hackingwithswift.com/favicon.svg",
  "background": "rgba(54,94,226,0.2)"
}
\`\`\`
`),n(s,t(a({title:"Static and class subscripts | Changes in Swift 5.1",desc:"Static and class subscripts",link:"/hackingwithswift.com/swift/5.1/static-subscripts.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n(s,t(a({title:"Warnings for ambiguous none cases | Changes in Swift 5.1",desc:"Warnings for ambiguous none cases",link:"/hackingwithswift.com/swift/5.1/ambiguous-none-enum.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n(s,t(a({title:"Matching optional enums against non-optionals | Changes in Swift 5.1",desc:"Matching optional enums against non-optionals",link:"/hackingwithswift.com/swift/5.1/matching-optional-enums.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n(s,t(a({title:"Ordered collection diffing | Changes in Swift 5.1",desc:"Ordered collection diffing",link:"/hackingwithswift.com/swift/5.1/ordered-collection-diffing.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n(s,t(a({title:"Creating uninitialized arrays | Changes in Swift 5.1",desc:"Creating uninitialized arrays",link:"/hackingwithswift.com/swift/5.1/creating-uninitialized-arrays.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e("p",null,[e("a",I,[n(o,{icon:"fas fa-file-zipper"}),i("Download Swift 5.1 playground")])])])])}const A=p(g,[["render",W],["__file","opaque-return-types.html.vue"]]),E=JSON.parse('{"path":"/hackingwithswift.com/swift/5.1/opaque-return-types.html","title":"Opaque return types","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Opaque return types","description":"Article(s) > Opaque return types","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","swift","swift-5.1"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Opaque return types"},{"property":"og:description","content":"Opaque return types"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/5.1/opaque-return-types.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/5.1/opaque-return-types.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Opaque return types"}],["meta",{"property":"og:description","content":"Article(s) > Opaque return types"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swift-5.1"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Opaque return types\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]],"isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":4.96,"words":1488},"filePathRelative":"hackingwithswift.com/swift/5.1/opaque-return-types.md","excerpt":"\\n"}');export{A as comp,E as data};
