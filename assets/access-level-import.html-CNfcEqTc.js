import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,b as e,t as d,e as t,n as a,g as i,d as s,a as h,f as m,r as l,o as g}from"./app-BgNevrm5.js";const u={},f={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},w={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},k=e("nav",{class:"table-of-contents"},[e("ul")],-1),b=e("hr",null,null,-1),v=e("blockquote",null,[e("p",null,"Available from Swift 6.0")],-1),y={href:"https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"apple/swift-evolution",-1),S=e("code",null,"private import SomeLibrary",-1),A=m(`<p>There are various ways this will be useful, including the ability for library developers to avoid accidentally leaking their own dependencies. For example, a banking app might be split into multiple parts:</p><ul><li>The app itself, presenting the user interface.</li><li>A Banking library that handles all the functionality and core logic.</li><li>Several smaller, internal libraries that handle individual pieces of work that are lower level, such as a Transactions package, a Networking package, and so on.</li></ul><p>So, the app depends on the Banking library, and the Banking library in turn depends on Transactions, Networking, and other internal libraries.</p><p>We can demonstrate that setup with some code that also demonstrates the problem being resolved here. First, we could say that the low-level Transactions package has a struct such as this one:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">BankTransaction</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// code here</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Up in the Banking library we might write a function to send money from one account number to another using that <code>BankTransaction</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">sendMoney</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">BankTransaction</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// handle sending money then send back the result</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">BankTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And now in the main app we can call <code>sendMoney()</code> to do the work.</p><p>That&#39;s all regular Swift code, but it can create a rather unpleasant problem: very often wrapper libraries don&#39;t want to reveal the inner workings of the libraries they rely on internally, which is exactly what happens here â€“ our main app is given access to the <code>BankTransaction</code> struct from the Transactions library, when really it should only use APIs from the Banking library.</p><p>From 6.0 onwards we can solve this problem by using access control on the import for Transactions: by using <code>internal import Transactions</code> or similar in the Banking library, Swift will refuse to build any code declared as public that exposes API from the Transactions library.</p><p>This really helps to clear up code boundaries: the Banking framework can still go ahead and use all the libraries it wants internally, but it won&#39;t be allowed to send those back to clients â€“ the app in this case â€“ by accident. If we genuinely did want to expose the internal framework types, we would use <code>public import Transactions</code> to make that explicit.</p><p>On a more fine-grained level, this also allows files inside the same module to add extra restrictions â€“ one file could privately import a framework without wanting to accidentally expose the contents of that framework elsewhere.</p><p>Although Swift 6 hasn&#39;t shipped yet, it&#39;s looking like the default for imports will be <code>internal</code> when running in Swift 6 mode, but <code>public</code> in Swift 5 mode to retain compatibility with existing code.</p>`,13),T={class:"hint-container details"},C=e("summary",null,"Other Changes in Swift 6.0",-1),B={href:"https://hackingwithswift.com/files/playgrounds/swift/playground-5-10-to-6-0.playground.zip",target:"_blank",rel:"noopener noreferrer"};function x(c,I){const n=l("VPCard"),o=l("FontIcon");return g(),p("div",null,[e("h1",f,[e("a",w,[e("span",null,d(c.$frontmatter.title)+" ê´€ë ¨",1)])]),t(n,a(i({title:"HACKING WITH SWIFT",desc:"What's new in Swift?",link:"/hackingwithswift.com/swift/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),k,b,t(n,a(i({title:"Access-level modifiers on import declarations | Changes in Swift 6.0",desc:"Access-level modifiers on import declarations",link:"https://hackingwithswift.com/swift/6.0/access-level-import",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),v,e("p",null,[e("a",y,[s("SE-0409 ("),t(o,{icon:"iconfont icon-github"}),_,s(")")]),s(" adds the ability to mark import declarations with access control modifiers, such as "),S,s(".")]),A,e("details",T,[C,t(n,a(i({title:"Complete concurrency enabled by default | Changes in Swift 6.0",desc:"Complete concurrency enabled by default",link:"/hackingwithswift.com/swift/6.0/concurrency.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(n,a(i({title:"count(where:) | Changes in Swift 6.0",desc:"count(where:)",link:"/hackingwithswift.com/swift/6.0/count-where.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(n,a(i({title:"Typed throws | Changes in Swift 6.0",desc:"Typed throws",link:"/hackingwithswift.com/swift/6.0/typed-throws.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(n,a(i({title:"Pack iteration | Changes in Swift 6.0",desc:"Pack iteration",link:"/hackingwithswift.com/swift/6.0/pack-iteration.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(n,a(i({title:"Add Collection Operations on Noncontiguous Elements | Changes in Swift 6.0",desc:"Add Collection Operations on Noncontiguous Elements",link:"/hackingwithswift.com/swift/6.0/rangeset.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),h(` 
\`\`\`component VPCard
{
  "title": "Access-level modifiers on import declarations | Changes in Swift 6.0",
  "desc": "Access-level modifiers on import declarations",
  "link": "/hackingwithswift.com/swift/6.0/access-level-import.md",
  "logo": "https://hackingwithswift.com/favicon.svg",
  "background": "rgba(54,94,226,0.2)"
}
\`\`\`
`),t(n,a(i({title:"Upgrades for noncopyable types | Changes in Swift 6.0",desc:"Upgrades for noncopyable types",link:"/hackingwithswift.com/swift/6.0/noncopyable-upgrades.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(n,a(i({title:"128-bit Integer Types | Changes in Swift 6.0",desc:"128-bit Integer Types",link:"/hackingwithswift.com/swift/6.0/int128.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),t(n,a(i({title:"BitwiseCopyable | Changes in Swift 6.0",desc:"BitwiseCopyable",link:"/hackingwithswift.com/swift/6.0/bitwisecopyable.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),e("p",null,[e("a",B,[t(o,{icon:"fas fa-file-zipper"}),s("Download Swift 6.0 playground")])])])])}const V=r(u,[["render",x],["__file","access-level-import.html.vue"]]),E=JSON.parse('{"path":"/hackingwithswift.com/swift/6.0/access-level-import.html","title":"Access-level modifiers on import declarations","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Access-level modifiers on import declarations","description":"Article(s) > Access-level modifiers on import declarations","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","swift","swift-6.0"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Access-level modifiers on import declarations"},{"property":"og:description","content":"Access-level modifiers on import declarations"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/6.0/access-level-import.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/6.0/access-level-import.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Access-level modifiers on import declarations"}],["meta",{"property":"og:description","content":"Article(s) > Access-level modifiers on import declarations"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swift-6.0"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Access-level modifiers on import declarations\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]],"isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":2.87,"words":862},"filePathRelative":"hackingwithswift.com/swift/6.0/access-level-import.md","excerpt":"\\n"}');export{V as comp,E as data};
