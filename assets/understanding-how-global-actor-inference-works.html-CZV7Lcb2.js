import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,b as n,t as l,e as s,n as e,g as t,f as r,r as p,o as d}from"./app-BgNevrm5.js";const u={},m={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},h={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},k=n("nav",{class:"table-of-contents"},[n("ul")],-1),f=n("hr",null,null,-1),w=r(`<blockquote><p>Updated for Xcode 15</p></blockquote><p>Apple explicitly annotates many of its types as being <code>@MainActor</code>, including most UIKit types such as <code>UIView</code> and <code>UIButton</code>. However, there are many places where types gain main-actor-ness <em>implicitly</em> through a process called <em>global actor inference</em> ‚Äì Swift applies <code>@MainActor</code> automatically based on a set of predetermined rules.</p><p>There are five rules for global actor inference, and I want to tackle them individually because although they start easy they get more complex.</p><p>First, if a class is marked <code>@MainActor</code>, all its subclasses are also automatically <code>@MainActor</code>. This follows the principle of least surprise: if you inherit from a <code>@MainActor</code> class it makes sense that your subclass is also <code>@MainActor</code>.</p><p>Second, if a method in a class is marked <code>@MainActor</code>, any overrides for that method are also automatically <code>@MainActor</code>. Again, this is a natural thing to expect ‚Äì you overrode a <code>@MainActor</code> method, so the only safe way Swift can call that override is if it‚Äôs also <code>@MainActor</code>.</p><p>Third, any struct or class using a property wrapper with <code>@MainActor</code> for its wrapped value will automatically be <code>@MainActor</code>. This is what makes <code>@StateObject</code> and <code>@ObservedObject</code> convey main-actor-ness on SwiftUI views that use them ‚Äì if you use either of those two property wrappers in a SwiftUI view, the whole view becomes <code>@MainActor</code> too. At the time of writing Xcode‚Äôs generated interface for those two property wrappers don‚Äôt show that they are annotated as <code>@MainActor</code>, but I‚Äôve been assured they definitely are ‚Äì hopefully Xcode can make that work better in the future.</p><p>The fourth rule is where the difficulty ramps up a little: if a protocol declares a method as being <code>@MainActor</code>, any type that conforms to that protocol will have that same method automatically be <code>@MainActor</code> <em>unless</em> you separate the conformance from the method.</p><p>What this means is that if you make a type conform to a protocol with a <code>@MainActor</code> method, and add the required method implementation at the same time, it is implicitly <code>@MainActor</code>. However, if you separate the conformance and the method implementation, you need to add <code>@MainActor</code> by hand.</p><p>Here‚Äôs that in code:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token comment">// A protocol with a single \`@MainActor\` method.</span></span>
<span class="line"><span class="token keyword">protocol</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token attribute atrule">@MainActor</span> <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// A struct that does not conform to the protocol.</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">DataStore1</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// When we make it conform and add save() at the same time, our method is implicitly @MainActor.</span></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">DataStore1</span><span class="token punctuation">:</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// This is automatically @MainActor.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// A struct that conforms to the protocol.</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">DataStore2</span><span class="token punctuation">:</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// If we later add the save() method, it will *not* be implicitly @MainActor so we need to mark it as such ourselves.</span></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">DataStore2</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token attribute atrule">@MainActor</span> <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As you can see, we need to explicitly use <code>@MainActor func save()</code> in <code>DataStore2</code> because the global actor inference does not apply there. Don‚Äôt worry about forgetting it, though ‚Äì Xcode will automatically check the annotation is there, and offer to add <code>@MainActor</code> if it‚Äôs missing.</p><p>The fifth and final rule is most complex of all: if the whole protocol is marked with <code>@MainActor</code>, any type that conforms to that protocol will also automatically be <code>@MainActor</code> <em>unless</em> you put the conformance separately from the main type declaration, in which case only the methods are <code>@MainActor</code>.</p><p>In attempt to make this clear, here‚Äôs what I mean:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token comment">// A protocol marked as @MainActor.</span></span>
<span class="line"><span class="token attribute atrule">@MainActor</span> <span class="token keyword">protocol</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// A struct that conforms to DataStoring as part of its primary type definition.</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">DataStore1</span><span class="token punctuation">:</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span> <span class="token comment">// This struct is automatically @MainActor.</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// This method is automatically @MainActor.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Another struct that conforms to DataStoring as part of its primary type definition.</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">DataStore2</span><span class="token punctuation">:</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// This struct is automatically @MainActor.</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// The method is provided in an extension, but it&#39;s the same as if it were in the primary type definition.</span></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">DataStore2</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// This method is automatically @MainActor.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// A third struct that does *not* conform to DataStoring in its primary type definition.</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">DataStore3</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// This struct is not @MainActor.</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// The conformance is added as an extension</span></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">DataStore3</span><span class="token punctuation">:</span> <span class="token class-name">DataStoring</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// This method is automatically @MainActor.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>I realize that might sound obscure, but it makes sense if you put it into a real-world context. For example, let‚Äôs say you were working with the <code>DataStoring</code> protocol we defined above ‚Äì what would happen if you modified one of Apple‚Äôs types so that it conformed to it?</p><p>If conformance to a <code>@MainActor</code> protocol retroactively made the whole of Apple‚Äôs type <code>@MainActor</code> then you would have dramatically altered the way it worked, probably breaking all sorts of assumptions made elsewhere in the system. If it‚Äôs <em>your</em> type ‚Äì a type you‚Äôre creating from scratch in your own code ‚Äì then you <em>can</em> add the protocol conformance as you make the type and therefore isolate the entire type to <code>@MainActor</code>, because it‚Äôs your choice.</p>`,16),y={class:"hint-container details"},g=n("summary",null,"Similar solutions‚Ä¶",-1);function v(o,b){const a=p("VPCard");return d(),c("div",null,[n("h1",m,[n("a",h,[n("span",null,l(o.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),s(a,e(t({title:"Swift Concurrency by Example",desc:"Back to Home",link:"/hackingwithswift.com/concurrency/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(174,10,10,0.2)"})),null,16),k,f,s(a,e(t({title:"Understanding how global actor inference works | Swift Concurrency by Example",desc:"Understanding how global actor inference works",link:"https://hackingwithswift.com/quick-start/understanding-how-global-actor-inference-works",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),w,n("details",y,[g,s(a,e(t({title:"Understanding how priority escalation works | Swift Concurrency by Example",desc:"Understanding how priority escalation works",link:"/hackingwithswift.com/concurrency/understanding-how-priority-escalation-works.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"What is an actor and why does Swift have them? | Swift Concurrency by Example",desc:"What is an actor and why does Swift have them?",link:"/hackingwithswift.com/concurrency/what-is-an-actor-and-why-does-swift-have-them.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"What is actor hopping and how can it cause problems? | Swift Concurrency by Example",desc:"What is actor hopping and how can it cause problems?",link:"/hackingwithswift.com/concurrency/what-is-actor-hopping-and-how-can-it-cause-problems.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"Important: Do not use an actor for your SwiftUI data models | Swift Concurrency by Example",desc:"Important: Do not use an actor for your SwiftUI data models",link:"/hackingwithswift.com/concurrency/important-do-not-use-an-actor-for-your-swiftui-data-models.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"How to create and use an actor in Swift | Swift Concurrency by Example",desc:"How to create and use an actor in Swift",link:"/hackingwithswift.com/concurrency/how-to-create-and-use-an-actor-in-swift.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16)])])}const M=i(u,[["render",v],["__file","understanding-how-global-actor-inference-works.html.vue"]]),x=JSON.parse('{"path":"/hackingwithswift.com/concurrency/understanding-how-global-actor-inference-works.html","title":"Understanding how global actor inference works","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Understanding how global actor inference works","description":"Article(s) > Understanding how global actor inference works","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Understanding how global actor inference works"},{"property":"og:description","content":"Understanding how global actor inference works"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/understanding-how-global-actor-inference-works.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/concurrency/understanding-how-global-actor-inference-works.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Understanding how global actor inference works"}],["meta",{"property":"og:description","content":"Article(s) > Understanding how global actor inference works"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:published_time","content":"2021-11-28T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Understanding how global actor inference works\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-11-28T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"date":"2021-11-28T00:00:00.000Z","isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":3.97,"words":1192},"filePathRelative":"hackingwithswift.com/concurrency/understanding-how-global-actor-inference-works.md","localizedDate":"2021ÎÖÑ 11Ïõî 28Ïùº","excerpt":"\\n"}');export{M as comp,x as data};
