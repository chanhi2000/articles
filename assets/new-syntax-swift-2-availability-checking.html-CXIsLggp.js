import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as u,b as a,t as d,e as n,n as o,g as l,w as e,f as h,r as c,o as m,d as t}from"./app-BgNevrm5.js";const k={},v={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},w={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},b={class:"table-of-contents"},y=a("hr",null,null,-1),g=h(`<p>Availability checking in Swift gives us the ability to ask whether the user is running a specific or newer version of an operating system, and run code only if that test passes. This allows us to use the latest functionality from iOS, macOS and so on, while also degrading gracefully for users on older iOS versions.</p><hr><h2 id="how-it-used-to-be-manual-version-checking" tabindex="-1"><a class="header-anchor" href="#how-it-used-to-be-manual-version-checking"><span>How it used to be: manual version checking</span></a></h2><p>Without Swift&#39;s availability checking, you would have to check for version compatibility by hand. For example, if you want to use <code>UICollectionViewCompositionalLayout</code> in your app but wanted to support users on iOS 12 and earlier, you&#39;d need to do a run-time operating system version number check and use that new layout only if it were supported. For example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token class-name">NSProcessInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOperatingSystemAtLeastVersion</span><span class="token punctuation">(</span><span class="token class-name">NSOperatingSystemVersion</span><span class="token punctuation">(</span>majorVersion<span class="token punctuation">:</span> <span class="token number">13</span><span class="token punctuation">,</span> minorVersion<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> patchVersion<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Create the collection view!&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This approach was fraught with problems, not least trying to remember when each component was introduced. Worse, what if you missed some code? If your app tried to use iOS 13 code on iOS 12, or iOS 12 code on iOS 11, it would just crash, which meant developers who were keen use the latest and greatest APIs had to spend a lot of time adding checks to their code, and ensuring it was crash-free.</p><hr><h2 id="swift-s-solution-automatic-operating-system-api-availability-checking" tabindex="-1"><a class="header-anchor" href="#swift-s-solution-automatic-operating-system-api-availability-checking"><span>Swift&#39;s solution: Automatic operating system API availability checking</span></a></h2><p>Way back in Swift 2, Apple introduced API availability checking. If you set your app&#39;s Deployment Target to a lower iOS release than the base SDK, Xcode will automatically scan every API you use to make sure it&#39;s available in your lowest deployment target version. This information has been in Apple&#39;s API headers for years, but it&#39;s only now being exposed to the compiler. What it means is that if your app compiles, you can be guaranteed it doesn&#39;t call any code that can&#39;t run because of missing APIs.</p><p>By default, you don&#39;t need to do anything: Swift will compare your actual usage against your minimum deployment target, and if it finds any unavailable API then you&#39;ll get an error ‚Äì and <em>that&#39;s</em> when the work begins.</p><p>Returning to our example, if you <em>have</em> used <code>UICollectionViewCompositionalLayout</code> and your deployment target is set to iOS 12.0, you&#39;ll get a compile error because stack views aren&#39;t available before 13.0. The solution is to tell Xcode you want certain code to execute only on iOS 13.0 or later, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token other-directive property">#available</span><span class="token punctuation">(</span>iOS <span class="token number">13</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// use UICollectionViewCompositionalLayout</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// show sad face emoji</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In that code, <code>#available</code> is going to check whether we&#39;re on iOS 13 or later, or any other unknown platforms that might get announced in the future ‚Äì that&#39;s the * at the end, and it&#39;s required. And that&#39;s it: all the code you&#39;ll put in place of &quot;// use UICollectionViewCompositionalLayout&quot; effectively has elevated rights to use iOS 13.0-only technology, whether that&#39;s classes, methods or enums.</p><p>If code inside a method should only be run on certain iOS versions, you can also use <code>#available</code> with <code>guard</code> to produce code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">guard</span> <span class="token other-directive property">#available</span><span class="token punctuation">(</span>iOS <span class="token number">13</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The power of <code>#available</code> is that the compiler can now check and enforce API usage on older operating systems, which previously was entirely human ‚Äì it&#39;s a huge improvement, and one I know will catch on quickly.</p><hr><h2 id="marking-whole-methods-and-classes-with-available" tabindex="-1"><a class="header-anchor" href="#marking-whole-methods-and-classes-with-available"><span>Marking whole methods and classes with @available</span></a></h2><p>As you just saw, you can use <code>if #available</code> to run version-specific code in small blocks. But what if whole methods are off limits? Or perhaps even whole classes? Swift has these scenarios covered too, using the <code>@available</code> attribute.</p><p><code>@available</code> works similarly to <code>#available</code> in that you specify the iOS release you want to target, and then Xcode handles the rest. For example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@available</span><span class="token punctuation">(</span>iOS <span class="token number">13</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">useCompositionalLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// use UICollectionViewCompositionalLayout</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If your deployment target is iOS 12, you can&#39;t call that <code>useCompositionalLayout()</code> method without some availability checking first. You can stack up these checks if you need to, for example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@available</span><span class="token punctuation">(</span>iOS <span class="token number">11</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">iOS11Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do stuff</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token other-directive property">#available</span><span class="token punctuation">(</span>iOS <span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">iOS12Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token attribute atrule">@available</span><span class="token punctuation">(</span>iOS <span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">iOS12Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do stuff</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token other-directive property">#available</span><span class="token punctuation">(</span>iOS <span class="token number">13</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">iOS13Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token attribute atrule">@available</span><span class="token punctuation">(</span>iOS <span class="token number">13</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">iOS13Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do stuff</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Each time, there&#39;s effectively a privilege elevation so you can use version-limited APIs.</p><p>For the ultimate in restrictions, you can also mark whole classes as being available only in a specific iOS release or later ‚Äì just move the <code>@available</code> code wherever you want it.</p><p>There is one last neat feature about these availability checks in Swift: you no longer need to worry about &quot;Required&quot; and &quot;Optional&quot; frameworks ‚Äì the compiler sorts all that out for you now. Hurray for developer productivity!</p>`,26);function f(p,S){const i=c("VPCard"),s=c("router-link");return m(),u("div",null,[a("h1",v,[a("a",w,[a("span",null,d(p.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),n(i,o(l({title:"Swift > Article(s)",desc:"Article(s)",link:"/programming/swift/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),a("nav",b,[a("ul",null,[a("li",null,[n(s,{to:"#how-it-used-to-be-manual-version-checking"},{default:e(()=>[t("How it used to be: manual version checking")]),_:1})]),a("li",null,[n(s,{to:"#swift-s-solution-automatic-operating-system-api-availability-checking"},{default:e(()=>[t("Swift's solution: Automatic operating system API availability checking")]),_:1})]),a("li",null,[n(s,{to:"#marking-whole-methods-and-classes-with-available"},{default:e(()=>[t("Marking whole methods and classes with @available")]),_:1})])])]),y,n(i,o(l({title:"Availability checking in Swift: backwards compatibility the smart way ‚Äì Hacking with Swift",desc:"Availability checking in Swift: backwards compatibility the smart way",link:"https://hackingwithswift.com/new-syntax-swift-2-availability-checking",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),g])}const x=r(k,[["render",f],["__file","new-syntax-swift-2-availability-checking.html.vue"]]),_=JSON.parse(`{"path":"/hackingwithswift.com/new-syntax-swift-2-availability-checking.html","title":"Availability checking in Swift: backwards compatibility the smart way","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Availability checking in Swift: backwards compatibility the smart way","description":"Article(s) > Availability checking in Swift: backwards compatibility the smart way","icon":"fa-brands fa-swift","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","ios","xcode"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Availability checking in Swift: backwards compatibility the smart way"},{"property":"og:description","content":"Availability checking in Swift: backwards compatibility the smart way"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/new-syntax-swift-2-availability-checking.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/new-syntax-swift-2-availability-checking.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Availability checking in Swift: backwards compatibility the smart way"}],["meta",{"property":"og:description","content":"Article(s) > Availability checking in Swift: backwards compatibility the smart way"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"ios"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:published_time","content":"2019-09-23T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Availability checking in Swift: backwards compatibility the smart way\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-09-23T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/programming/swift/articles/README.md","date":"2019-09-23T00:00:00.000Z","isOriginal":false},"headers":[{"level":2,"title":"How it used to be: manual version checking","slug":"how-it-used-to-be-manual-version-checking","link":"#how-it-used-to-be-manual-version-checking","children":[]},{"level":2,"title":"Swift's solution: Automatic operating system API availability checking","slug":"swift-s-solution-automatic-operating-system-api-availability-checking","link":"#swift-s-solution-automatic-operating-system-api-availability-checking","children":[]},{"level":2,"title":"Marking whole methods and classes with @available","slug":"marking-whole-methods-and-classes-with-available","link":"#marking-whole-methods-and-classes-with-available","children":[]}],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":3.16,"words":949},"filePathRelative":"hackingwithswift.com/new-syntax-swift-2-availability-checking.md","localizedDate":"2019ÎÖÑ 9Ïõî 23Ïùº","excerpt":"\\n"}`);export{x as comp,_ as data};
