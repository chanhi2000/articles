import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,b as s,t as k,e as a,n as p,g as l,w as o,d as n,f as h,r as c,o as m}from"./app-BgNevrm5.js";const w={},f={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},v={class:"table-of-contents"},b=s("hr",null,null,-1),y={href:"https://github.com/apple/swift/pull/5600/files",target:"_blank",rel:"noopener noreferrer"},x=s("code",null,"apple/swift",-1),S={href:"https://github.com/apple/swift/pull/5126/files",target:"_blank",rel:"noopener noreferrer"},_=s("code",null,"apple/swift",-1),q=s("p",null,"In this article I'm going to explain three of the most useful changes with code examples, and hopefully this will give you some chance to be prepared to update your code when the time comes.",-1),T=s("div",{class:"hint-container warning"},[s("p",{class:"hint-container-title"},"Warning"),s("p",null,"Although it is not a feature of Swift 3.1, I couldn't publish this article without mentioning that Xcode 8.3 drops support for Swift 2.3. So, if you were holding back on your migration to Swift 3.x, now is the time to make the switch!")],-1),A=s("p",null,"If you liked this article, you might also enjoy these:",-1),M=h(`<hr><h2 id="concrete-constrained-extensions" tabindex="-1"><a class="header-anchor" href="#concrete-constrained-extensions"><span>Concrete constrained extensions</span></a></h2><p>Swift lets us extend types using constraints, which is a powerful and expressive way to add functionality. To demonstrate this, let&#39;s look at a worked example in Swift 3.0 that modifies collections to do something trivial:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Iterator</span><span class="token punctuation">.</span><span class="token class-name">Element</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">lessThanFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token class-name">Iterator</span><span class="token punctuation">.</span><span class="token class-name">Element</span><span class="token punctuation">]</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>first <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&lt;</span> first <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lessThanFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That adds a new method called <code>lessThanFirst()</code>, which returns all items in a collection that are less than the first item. So, using it with the array <code>[5, 6, 10, 4, 110, 3]</code> will return <code>[4, 3]</code>.</p><p>That code extends a protocol (<code>Collection</code>) only where it matches a constraint: elements in the collection must conform to another protocol, <code>Comparable</code>. This alone is powerful stuff, but let&#39;s take it back a step: what if we wanted something a bit more specific? Swift 3.0 lets us extend a concrete type rather than the protocol <code>Collection</code>, so instead we could write this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Array</span> <span class="token keyword">where</span> <span class="token class-name">Element</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">lessThanFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token class-name">Element</span><span class="token punctuation">]</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>first <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&lt;</span> first <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lessThanFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That extends a concrete type (only <code>Array</code>) but still using a protocol for its constraint. What if we wanted to go even more specific ‚Äì extend a concrete type with a concrete constraint, for example only arrays that contains integers? Well, it turns out that isn&#39;t possible in Swift 3.0, which usually strikes people as odd: if Swift 3.0 can handle extending protocols with another protocol as a constraint, then surely extending a specific type with a specific constraint should be a cinch?</p><p>Fortunately, this discrepancy has been removed in Swift 3.1, which means we can now write code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Array</span> <span class="token keyword">where</span> <span class="token class-name">Element</span> <span class="token operator">==</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">lessThanFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>first <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&lt;</span> first <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lessThanFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That extends a concrete type (only <code>Array</code>) and uses a concrete constraint (only where the elements are <code>Int</code>).</p><p>Now, obviously we&#39;re using a trivial example here ‚Äì in your own code this is going to be significantly more useful when you want to extend arrays containing your own custom structs.</p><hr><h2 id="generics-with-nested-types" tabindex="-1"><a class="header-anchor" href="#generics-with-nested-types"><span>Generics with nested types</span></a></h2><p>Swift 3.0&#39;s support for nested types is useful to help you organize your data and increase encapsulation, but Swift 3.1 takes them to the next level by adding support for generics. Let&#39;s look at a simple example again, just to start with:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">Attachment</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> contents<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> title<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">var</span> attachment<span class="token punctuation">:</span> <span class="token class-name">Attachment</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That creates a <code>Message</code> struct that has an <code>Attachment</code> struct inside it ‚Äì a nested type. I&#39;ve added two <code>String</code> properties, because messages will have some text and attachments will hold some text.</p><p>Now, what if we wanted either <code>Message</code> or <code>Attachment</code> to have different kinds of data ‚Äì perhaps <code>Int</code> or <code>Data</code>? Well, that requires generics, so you might have found yourself writing something like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Message</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">Attachment</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> contents<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> title<span class="token punctuation">:</span> <span class="token class-name">T</span></span>
<span class="line">    <span class="token keyword">var</span> attachment<span class="token punctuation">:</span> <span class="token class-name">Attachment</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That tells Swift we want <code>Message</code> to work across several data types, and whatever data type gets used to create the struct should also be used for the <code>title</code> property. Or at least that&#39;s what it <em>would</em> tell Swift, if such code were actually legal ‚Äì Swift 3.0 does not allow you to mix nested type with generics. Fortunately, this is exactly what Swift 3.1 allows, because nested types can now appear inside generic types.</p><p>Not content to stop there, Swift 3.1 takes this a step further: nested types can <em>also</em> be generic, either using their own generic type or by inheriting the generic type of their parent. For example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Message</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">Attachment</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> contents<span class="token punctuation">:</span> <span class="token class-name">T</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> title<span class="token punctuation">:</span> <span class="token class-name">T</span></span>
<span class="line">    <span class="token keyword">var</span> attachment<span class="token punctuation">:</span> <span class="token class-name">Attachment</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>With that code, the <code>Message</code> struct will have a specific type assigned to it, and the <code>Attachment</code> struct will always have the same type ‚Äì you can&#39;t use <code>String</code> for one and <code>Int</code> for the other. So, this code will work fine:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> msg <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">,</span> attachment<span class="token punctuation">:</span> <span class="token class-name">Message</span><span class="token punctuation">.</span><span class="token class-name">Attachment</span><span class="token punctuation">(</span>contents<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Helpfully, if your goal is to make the nested type and its container use the same generic type, you don&#39;t even need to declare the nested type as generic ‚Äì Swift makes the outer type available to the nested type, so in fact you can just write this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Message</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">Attachment</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> contents<span class="token punctuation">:</span> <span class="token class-name">T</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> title<span class="token punctuation">:</span> <span class="token class-name">T</span></span>
<span class="line">    <span class="token keyword">var</span> attachment<span class="token punctuation">:</span> <span class="token class-name">Attachment</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Generics are great and so are nested types, so I&#39;m really pleased to see Swift 3.1 bring them together at last.</p><hr><h2 id="sequences-get-prefix-while-and-drop-while-methods" tabindex="-1"><a class="header-anchor" href="#sequences-get-prefix-while-and-drop-while-methods"><span>Sequences get prefix(while:) and drop(while:) methods</span></a></h2><p>Two useful new methods have been added to the <code>Sequence</code> protocol: <code>prefix(while:)</code> and <code>drop(while:)</code>. The former returns the longest subsequence that satisfies a predicate, which is a fancy way of saying that you give it a closure to run on every item, and it will go through all the elements in the sequence and return those that match the closure ‚Äì but will stop as soon as it finds a non-matching element.</p><p>Let&#39;s take a look at a code example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Michael Jackson&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Michael Jordan&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Michael Caine&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Taylor Swift&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Adele Adkins&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Michael Douglas&quot;</span></span><span class="token punctuation">]</span></span>
<span class="line"><span class="token keyword">let</span> prefixed <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token keyword">prefix</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Michael&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>prefixed<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That uses the <code>hasPrefix()</code> method to return the subsequence <code>[&quot;Michael Jackson&quot;, &quot;Michael Jordan&quot;, &quot;Michael Caine&quot;</code> ‚Äì the first three elements in the sequence. It won&#39;t include &quot;Michael Douglas&quot;, because that comes after the first non-Michael. If you wanted <em>all</em> the Michaels regardless of their position, you should use <code>filter()</code> instead.</p><p>The second new method, <code>drop(while:)</code> is effectively the opposite: it finds the longest subsequence that satisfies your predicate, then returns everything <em>after</em> it. For example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Michael Jackson&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Michael Jordan&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Michael Caine&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Taylor Swift&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Adele Adkins&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Michael Douglas&quot;</span></span><span class="token punctuation">]</span></span>
<span class="line"><span class="token keyword">let</span> dropped <span class="token operator">=</span> names<span class="token punctuation">.</span>drop <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Michael&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>dropped<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That will return the subsequence <code>[&quot;Taylor Swift&quot;, &quot;Adele Adkins&quot;, &quot;Michael Douglas&quot;]</code> ‚Äì everything after the initial Michaels.</p><hr><h2 id="looking-forward-to-swift-4-0" tabindex="-1"><a class="header-anchor" href="#looking-forward-to-swift-4-0"><span>Looking forward to Swift 4.0‚Ä¶</span></a></h2><p>Swift 4.0 is almost certainly going to see the light of day in June, with a full release a few months afterwards. Although a major goal is to provide source stability for Swift 3 code, some breaking changes are almost inevitable.</p>`,39),I={href:"https://github.com/apple/swift/blob/master/docs/StringManifesto.md",target:"_blank",rel:"noopener noreferrer"},C=s("code",null,"apple/swift",-1),W={href:"https://hackingwithswift.com/store/swift-coding-challenges",target:"_blank",rel:"noopener noreferrer"},j={href:"https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md",target:"_blank",rel:"noopener noreferrer"},F=s("code",null,"apple/swift",-1);function E(r,P){const i=c("VPCard"),t=c("router-link"),e=c("FontIcon");return m(),d("div",null,[s("h1",f,[s("a",g,[s("span",null,k(r.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),a(i,p(l({title:"Swift > Article(s)",desc:"Article(s)",link:"/programming/swift/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",v,[s("ul",null,[s("li",null,[a(t,{to:"#concrete-constrained-extensions"},{default:o(()=>[n("Concrete constrained extensions")]),_:1})]),s("li",null,[a(t,{to:"#generics-with-nested-types"},{default:o(()=>[n("Generics with nested types")]),_:1})]),s("li",null,[a(t,{to:"#sequences-get-prefix-while-and-drop-while-methods"},{default:o(()=>[n("Sequences get prefix(while:) and drop(while:) methods")]),_:1})]),s("li",null,[a(t,{to:"#looking-forward-to-swift-4-0"},{default:o(()=>[n("Looking forward to Swift 4.0‚Ä¶")]),_:1})])])]),b,a(i,p(l({title:"What's new in Swift 3.1 ‚Äì Hacking with Swift",desc:"What's new in Swift 3.1",link:"https://hackingwithswift.com/swift3-1",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s("p",null,[n("Swift 3.1 is a small, backwards-compatible update to Swift 3.0, cleaning up a few advanced features in preparation for more serious changes coming when Swift 4.0 is announced in June. Although it took a lot of behind-the-scenes work to make these changes happen (see "),s("a",y,[n("here ("),a(e,{icon:"iconfont icon-github"}),x,n(")")]),n(" and "),s("a",S,[n("here ("),a(e,{icon:"iconfont icon-github"}),_,n(")")]),n(" if you'd like some detail), the end result for developers is a few extra features that we'll be able to start using soon enough.")]),q,T,A,a(i,p(l({title:"What's new in Swift 3.0 ‚Äì Hacking with Swift",desc:"What's new in Swift 3.0",link:"/hackingwithswift.com/swift3",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),M,s("p",null,[n("If you want to take a peek into the future, you should "),s("a",I,[n("read the String Processing For Swift document ("),a(e,{icon:"iconfont icon-github"}),C,n(")")]),n(" from two of Apple's Swift engineers ‚Äì yes, code will break, but hopefully this will result in strings being significantly easier for developers to work with. If you worked through the string problems in my "),s("a",W,[a(e,{icon:"fas fa-globe"}),n("Swift Coding Challenges")]),n(" book, you'll know how tricky strings can be right now.")]),s("p",null,[n("One feature we're all hoping for is true "),s("a",j,[n("ABI compatibility ("),a(e,{icon:"iconfont icon-github"}),F,n(")")]),n(", which would allow developers to distribute compiled libraries ‚Äì one of the few key missing features that remain in Swift today. It would also reduce the size of every Swift app because iOS could store Swift's runtime libraries rather than them being distributed with every Swift app, so we get faster uploads to iTunes Connect, faster downloads to users, and slimmer apps all around. Hurray!")])])}const N=u(w,[["render",E],["__file","swift3-1.html.vue"]]),R=JSON.parse(`{"path":"/hackingwithswift.com/swift3-1.html","title":"What's new in Swift 3.1","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"What's new in Swift 3.1","description":"What's new in Swift 3.1","icon":"fa-brands fa-swift","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","crashcourse","swift","swift-3.1","ios","xcode"],"head":[[{"meta":null},{"property":"og:title","content":"What's new in Swift 3.1"},{"property":"og:description","content":"What's new in Swift 3.1"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift3-1.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift3-1.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"What's new in Swift 3.1"}],["meta",{"property":"og:description","content":"What's new in Swift 3.1"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swift-3.1"}],["meta",{"property":"article:tag","content":"ios"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:published_time","content":"2017-01-26T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"What's new in Swift 3.1\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-01-26T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]],"prev":"/programming/swift/articles/README.md","date":"2017-01-26T00:00:00.000Z","isOriginal":false},"headers":[{"level":2,"title":"Concrete constrained extensions","slug":"concrete-constrained-extensions","link":"#concrete-constrained-extensions","children":[]},{"level":2,"title":"Generics with nested types","slug":"generics-with-nested-types","link":"#generics-with-nested-types","children":[]},{"level":2,"title":"Sequences get prefix(while:) and drop(while:) methods","slug":"sequences-get-prefix-while-and-drop-while-methods","link":"#sequences-get-prefix-while-and-drop-while-methods","children":[]},{"level":2,"title":"Looking forward to Swift 4.0‚Ä¶","slug":"looking-forward-to-swift-4-0","link":"#looking-forward-to-swift-4-0","children":[]}],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":5.27,"words":1580},"filePathRelative":"hackingwithswift.com/swift3-1.md","localizedDate":"2017ÎÖÑ 1Ïõî 26Ïùº","excerpt":"\\n"}`);export{N as comp,R as data};
