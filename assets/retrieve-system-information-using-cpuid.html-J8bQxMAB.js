import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as v,b as e,t as b,e as s,n as d,g as p,w as t,d as n,a as u,f as r,r as l,o as f}from"./app-BgNevrm5.js";const g={},_={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},E={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},C={class:"table-of-contents"},D=e("hr",null,null,-1),I=e("p",null,"When developing a bootloader/kernel, understanding the underlying architecture is crucial for optimizing performance and compatibility between software and hardware.",-1),P=e("p",null,"One important yet sometimes overlooked tool available to engineers for querying and retrieving system information is the CPUID instruction.",-1),U=e("hr",null,null,-1),y=e("h2",{id:"what-is-the-cpuid-instruction",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#what-is-the-cpuid-instruction"},[e("span",null,"What is the CPUID Instruction?")])],-1),A=e("p",null,"The CPUID instruction is a low level instruction, inside the heart of every modern x86 and x86-64 processor that allows the software to query the CPU for information about the processor and its supported features.",-1),w={href:"https://en.wikipedia.org/wiki/Single_instruction,_multiple_data",target:"_blank",rel:"noopener noreferrer"},S=r('<p>For bootloader or kernel developers, understanding what features a processor supportsâ€”such as hardware virtualization, cache sizes, or SIMD instructionsâ€”can ensure that the system runs efficiently and that the code you write is compatible across different CPUs. By utilizing the CPUID instruction, you can dynamically adjust your kernelâ€™s behavior based on the specific processor it is running on.</p><p>In this article you will learn how to check if the CPUID instruction is available for your system, how it works and what information you can get from using it.</p><hr><h2 id="prerequisites" tabindex="-1"><a class="header-anchor" href="#prerequisites"><span>Prerequisites</span></a></h2><ul><li>Some knowledge of assembly language (for this example I use FASM)</li><li>Some knowledge of operating systems/kernels</li><li>Access to low-level debugging tools (for example, GDB) or hardware emulators like QEMU to test your bootloader/kernel on various platforms.</li></ul><hr><h2 id="step-1-check-for-cpuid-availability" tabindex="-1"><a class="header-anchor" href="#step-1-check-for-cpuid-availability"><span>Step 1: Check for CPUID Availability</span></a></h2><p>Before executing the CPUID instruction, it&#39;s important to determine whether the processor supports it, as not all CPUs are guaranteed to have this functionality. The following code checks the availability of the CPUID instruction by modifying and testing the ID bit (bit 21) in the EFLAGS register.</p>',8),T={href:"https://wiki.osdev.org/Expanded_Main_Page",target:"_blank",rel:"noopener noreferrer"},x=r(`<figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1727637307676/82ad4bf5-3906-49a3-a12a-6cb83cc852db.png" alt="https://wiki.osdev.org/CPU_Registers_x86" tabindex="0" loading="lazy"><figcaption>https://wiki.osdev.org/CPU_Registers_x86</figcaption></figure><p>If the processor allows this bit to be toggled, CPUID is supported; otherwise, it is not. Here&#39;s how the detection process works:</p><p>(most people think that in Real mode 32 registers are not accessible. That is not true. All 32bit registers are usable)</p><div class="language-x86asm line-numbers-mode" data-highlighter="prismjs" data-ext="x86asm" data-title="x86asm"><pre><code><span class="line">cpuid_check:</span>
<span class="line">    pusha                                ; save state</span>
<span class="line">    pushfd                               ; Save EFLAGS</span>
<span class="line">    pushfd                               ; Store EFLAGS</span>
<span class="line">    xor dword [esp],0x00200000           ; Invert the ID bit in stored EFLAGS</span>
<span class="line">    popfd                                ; Load stored EFLAGS (with ID bit inverted)</span>
<span class="line">    pushfd                               ; Store EFLAGS again (ID bit may or may not be inverted)</span>
<span class="line">    pop eax                              ; eax = modified EFLAGS (ID bit may or may not be inverted)</span>
<span class="line">    xor eax,[esp]                        ; eax = whichever bits were changed</span>
<span class="line">    popfd                                ; Restore original EFLAGS</span>
<span class="line">    and eax,0x00200000                   ; eax = zero if ID bit can&#39;t be changed, else non-zero</span>
<span class="line">    cmp eax,0x00</span>
<span class="line">    je .cpuid_instruction_not_is_available</span>
<span class="line">.cpuid_instruction_is_available:</span>
<span class="line">    ;handle CPUID exists</span>
<span class="line">.cpuid_instruction_not_is_available:</span>
<span class="line">    ;handle CPUID isn&#39;t supported</span>
<span class="line">.cpuid_check_end:</span>
<span class="line">    popa                                  ; restore state</span>
<span class="line">    ret</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>pusha</code>: Saves all the general purpose registers to ensure the original state can be restored at the end.</li><li><code>pushfd</code>: Saves the current EFLAGS register.</li><li><code>pushfd</code>: Stores a copy of the EFLAGS.</li><li><code>xor dword [esp], 0x00200000</code>: The code flips the ID bit (21) of the EFLAGS using the XOR operator.</li><li><code>popfd</code>: Restores the modified EFLAGS with the ID bit inverted.</li><li><code>pushfd</code>: Pushes the modified EFLAGS back to the stack.</li><li><code>pop eax</code>: Puts the modified EFLAGS (ID bit may or may not be inverted) in the EAX register.</li><li><code>xor eax, [esp]</code>: After the XOR operation, the EAX will contain the bits that were changed.</li><li><code>popfd</code>: Restores the original EFLAGS.</li><li><code>and eax, 0x00200000</code>: The <code>and</code> operation isolates the 21st bit (ID bit) by masking all other bits. After this operation the EAX register will contain either 0x00200000 (if 21 bit was changed which means CPUID is supported) or 0Ã—00 (21 bit hasnâ€™t changed, CPUID not supported).</li><li><code>cmp eax, 0x00</code>: The CMP instruction checks the result of the previous operation. If EAX equals 0Ã—00, it means that the ID bit cannot be modified and the processor doesnâ€™t support the CPUID instruction. If it is not zero, it means that the ID bit was flipped and your processor supports the CPUID instruction.</li></ul><hr><h2 id="step-2-how-to-use-the-cpuid-instruction" tabindex="-1"><a class="header-anchor" href="#step-2-how-to-use-the-cpuid-instruction"><span>Step 2: How to Use The CPUID Instruction</span></a></h2><h3 id="get-cpu-features" tabindex="-1"><a class="header-anchor" href="#get-cpu-features"><span>Get CPU Features</span></a></h3><p>The CPUID instruction will return different information with different values in the EAX register.</p><div class="language-x86asm line-numbers-mode" data-highlighter="prismjs" data-ext="x86asm" data-title="x86asm"><pre><code><span class="line">mov eax, 0x1</span>
<span class="line">cpuid</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,10),F={href:"https://wiki.osdev.org/CPUID",target:"_blank",rel:"noopener noreferrer"},X=r(`<div class="language-x86asm line-numbers-mode" data-highlighter="prismjs" data-ext="x86asm" data-title="x86asm"><pre><code><span class="line">enum {</span>
<span class="line">    CPUID_FEAT_ECX_SSE3         = 1 &lt;&lt; 0,</span>
<span class="line">    CPUID_FEAT_ECX_PCLMUL       = 1 &lt;&lt; 1,</span>
<span class="line">    CPUID_FEAT_ECX_DTES64       = 1 &lt;&lt; 2,</span>
<span class="line">    CPUID_FEAT_ECX_MONITOR      = 1 &lt;&lt; 3,</span>
<span class="line">    CPUID_FEAT_ECX_DS_CPL       = 1 &lt;&lt; 4,</span>
<span class="line">    CPUID_FEAT_ECX_VMX          = 1 &lt;&lt; 5,</span>
<span class="line">    CPUID_FEAT_ECX_SMX          = 1 &lt;&lt; 6,</span>
<span class="line">    CPUID_FEAT_ECX_EST          = 1 &lt;&lt; 7,</span>
<span class="line">    CPUID_FEAT_ECX_TM2          = 1 &lt;&lt; 8,</span>
<span class="line">    CPUID_FEAT_ECX_SSSE3        = 1 &lt;&lt; 9,</span>
<span class="line">    CPUID_FEAT_ECX_CID          = 1 &lt;&lt; 10,</span>
<span class="line">    CPUID_FEAT_ECX_SDBG         = 1 &lt;&lt; 11,</span>
<span class="line">    CPUID_FEAT_ECX_FMA          = 1 &lt;&lt; 12,</span>
<span class="line">    CPUID_FEAT_ECX_CX16         = 1 &lt;&lt; 13,</span>
<span class="line">    CPUID_FEAT_ECX_XTPR         = 1 &lt;&lt; 14,</span>
<span class="line">    CPUID_FEAT_ECX_PDCM         = 1 &lt;&lt; 15,</span>
<span class="line">    CPUID_FEAT_ECX_PCID         = 1 &lt;&lt; 17,</span>
<span class="line">    CPUID_FEAT_ECX_DCA          = 1 &lt;&lt; 18,</span>
<span class="line">    CPUID_FEAT_ECX_SSE4_1       = 1 &lt;&lt; 19,</span>
<span class="line">    CPUID_FEAT_ECX_SSE4_2       = 1 &lt;&lt; 20,</span>
<span class="line">    CPUID_FEAT_ECX_X2APIC       = 1 &lt;&lt; 21,</span>
<span class="line">    CPUID_FEAT_ECX_MOVBE        = 1 &lt;&lt; 22,</span>
<span class="line">    CPUID_FEAT_ECX_POPCNT       = 1 &lt;&lt; 23,</span>
<span class="line">    CPUID_FEAT_ECX_TSC          = 1 &lt;&lt; 24,</span>
<span class="line">    CPUID_FEAT_ECX_AES          = 1 &lt;&lt; 25,</span>
<span class="line">    CPUID_FEAT_ECX_XSAVE        = 1 &lt;&lt; 26,</span>
<span class="line">    CPUID_FEAT_ECX_OSXSAVE      = 1 &lt;&lt; 27,</span>
<span class="line">    CPUID_FEAT_ECX_AVX          = 1 &lt;&lt; 28,</span>
<span class="line">    CPUID_FEAT_ECX_F16C         = 1 &lt;&lt; 29,</span>
<span class="line">    CPUID_FEAT_ECX_RDRAND       = 1 &lt;&lt; 30,</span>
<span class="line">    CPUID_FEAT_ECX_HYPERVISOR   = 1 &lt;&lt; 31,</span>
<span class="line"></span>
<span class="line">    CPUID_FEAT_EDX_FPU          = 1 &lt;&lt; 0,</span>
<span class="line">    CPUID_FEAT_EDX_VME          = 1 &lt;&lt; 1,</span>
<span class="line">    CPUID_FEAT_EDX_DE           = 1 &lt;&lt; 2,</span>
<span class="line">    CPUID_FEAT_EDX_PSE          = 1 &lt;&lt; 3,</span>
<span class="line">    CPUID_FEAT_EDX_TSC          = 1 &lt;&lt; 4,</span>
<span class="line">    CPUID_FEAT_EDX_MSR          = 1 &lt;&lt; 5,</span>
<span class="line">    CPUID_FEAT_EDX_PAE          = 1 &lt;&lt; 6,</span>
<span class="line">    CPUID_FEAT_EDX_MCE          = 1 &lt;&lt; 7,</span>
<span class="line">    CPUID_FEAT_EDX_CX8          = 1 &lt;&lt; 8,</span>
<span class="line">    CPUID_FEAT_EDX_APIC         = 1 &lt;&lt; 9,</span>
<span class="line">    CPUID_FEAT_EDX_SEP          = 1 &lt;&lt; 11,</span>
<span class="line">    CPUID_FEAT_EDX_MTRR         = 1 &lt;&lt; 12,</span>
<span class="line">    CPUID_FEAT_EDX_PGE          = 1 &lt;&lt; 13,</span>
<span class="line">    CPUID_FEAT_EDX_MCA          = 1 &lt;&lt; 14,</span>
<span class="line">    CPUID_FEAT_EDX_CMOV         = 1 &lt;&lt; 15,</span>
<span class="line">    CPUID_FEAT_EDX_PAT          = 1 &lt;&lt; 16,</span>
<span class="line">    CPUID_FEAT_EDX_PSE36        = 1 &lt;&lt; 17,</span>
<span class="line">    CPUID_FEAT_EDX_PSN          = 1 &lt;&lt; 18,</span>
<span class="line">    CPUID_FEAT_EDX_CLFLUSH      = 1 &lt;&lt; 19,</span>
<span class="line">    CPUID_FEAT_EDX_DS           = 1 &lt;&lt; 21,</span>
<span class="line">    CPUID_FEAT_EDX_ACPI         = 1 &lt;&lt; 22,</span>
<span class="line">    CPUID_FEAT_EDX_MMX          = 1 &lt;&lt; 23,</span>
<span class="line">    CPUID_FEAT_EDX_FXSR         = 1 &lt;&lt; 24,</span>
<span class="line">    CPUID_FEAT_EDX_SSE          = 1 &lt;&lt; 25,</span>
<span class="line">    CPUID_FEAT_EDX_SSE2         = 1 &lt;&lt; 26,</span>
<span class="line">    CPUID_FEAT_EDX_SS           = 1 &lt;&lt; 27,</span>
<span class="line">    CPUID_FEAT_EDX_HTT          = 1 &lt;&lt; 28,</span>
<span class="line">    CPUID_FEAT_EDX_TM           = 1 &lt;&lt; 29,</span>
<span class="line">    CPUID_FEAT_EDX_IA64         = 1 &lt;&lt; 30,</span>
<span class="line">    CPUID_FEAT_EDX_PBE          = 1 &lt;&lt; 31</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A brief explanation of the CPU features above:</p><ul><li><code>PCLMUL, AES</code>: Cryptographic instruction sets for fast encryption and decryption.</li><li><code>VMX, SMX</code>: Virtualization support for running virtual machines.</li><li><code>SSE3, SSSE3, SSE4.1, SSE4.2, AVX</code>: SIMD instruction sets for faster multimedia, math, and vector processing.</li><li><code>FMA</code>: Fused Multiply-Add, improves performance in floating-point calculations.</li><li><code>RDRAND</code>: Random number generator.</li><li><code>X2APIC</code>: Advanced interrupt handling in multiprocessor systems.</li><li><code>PCID</code>: Optimizes memory management during context switches.</li><li><code>FPU</code>: Hardware floating-point unit for faster math operations.</li><li><code>PAE</code>: Physical Address Extension, allows addressing more than 4 GB of memory.</li><li><code>HTT</code>: Allows a single CPU core to handle multiple threads.</li><li><code>PAT, PGE</code>: Memory management features for controlling caching and page mapping.</li><li><code>MMX, SSE, SSE2</code>: Older SIMD instruction sets for multimedia processing.</li></ul><hr><h2 id="get-cpu-vendor-string" tabindex="-1"><a class="header-anchor" href="#get-cpu-vendor-string"><span>Get CPU Vendor String</span></a></h2><p>If you want to get the CPU vendor string, EAX should be set to 0Ã—0 before invoking the CPUID instruction.</p><div class="language-x86asm line-numbers-mode" data-highlighter="prismjs" data-ext="x86asm" data-title="x86asm"><pre><code><span class="line">mov eax, 0x0</span>
<span class="line">cpuid</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>The vendor string is a unique identifier that CPU vendors like AMD and Intel use. Examples are: GenuineIntel (for Intel processors) or AuthenticAMD (for AMD processors). It basically specifies the manufacturer of the CPU.</p><p>The vendor string allows the kernel to identify the CPU manufacturer which is very useful because different manufacturers implement certain features differently. Also, software or drivers can interact differently based on the CPU manufacturer to ensure compatibility.</p><p>When used like this, the vendor id string will be returned in EBX, EDX, ECX registers. You can write them to a buffer and get the full 12 character string.</p><p>Example code:</p><h3 id="step-1-the-buffer" tabindex="-1"><a class="header-anchor" href="#step-1-the-buffer"><span>Step 1: The Buffer</span></a></h3><p>Create a buffer that can hold 12 bytes:</p><div class="language-x86asm line-numbers-mode" data-highlighter="prismjs" data-ext="x86asm" data-title="x86asm"><pre><code><span class="line">buffer: db 12 dup(0), 0xA, 0xD, 0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="step-2-print-the-buffer" tabindex="-1"><a class="header-anchor" href="#step-2-print-the-buffer"><span>Step 2: Print the Buffer</span></a></h2><p>We start by creating a string printing function.</p><p>This assembly code reads a string character by character and prints it to the screen using BIOS interrupt 0x10. The <code>print</code> function loops through the string and uses the <code>lodsb</code> instruction to load each character in the <code>al</code> register.</p><p>Then the <code>print_char</code> function uses the interrupt 0Ã—10 to print it on the screen. When the code reaches the end of the string (null terminator), the loop ends.</p><div class="language-asm line-numbers-mode" data-highlighter="prismjs" data-ext="asm" data-title="asm"><pre><code><span class="line">print_string:</span>
<span class="line">    call print</span>
<span class="line">    ret</span>
<span class="line">print:</span>
<span class="line">.loop:  </span>
<span class="line">    lodsb   ;read character to al and then increment</span>
<span class="line">    cmp al ,0 ;check if we reached the end</span>
<span class="line">    je .done  ;we reached null terminator, finish</span>
<span class="line">    call print_char ;print character</span>
<span class="line">    jmp .loop   ;jump back into the loop</span>
<span class="line">.done:</span>
<span class="line">    ret</span>
<span class="line">print_char:</span>
<span class="line">    mov ah, 0eh</span>
<span class="line">    int 0x10</span>
<span class="line">    ret</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="step-3-fill-the-buffer-and-print-it" tabindex="-1"><a class="header-anchor" href="#step-3-fill-the-buffer-and-print-it"><span>Step 3: Fill the Buffer and Print it</span></a></h3><p>Here, after saving the current state using the <code>pusha</code> instruction and calling <code>cpuid</code> with 0Ã—0 passed in the EAX register, we can store the contents of <code>ebx</code>, <code>edx</code>, <code>ecx</code> to the buffer. Then we call <code>print_string</code> to print it.</p><div class="language-asm line-numbers-mode" data-highlighter="prismjs" data-ext="asm" data-title="asm"><pre><code><span class="line">get_cpu_vendor:</span>
<span class="line">    pusha</span>
<span class="line">    mov eax, 0x0</span>
<span class="line">    cpuid</span>
<span class="line">    mov [buffer], ebx</span>
<span class="line">    mov [buffer + 4], edx</span>
<span class="line">    mov [buffer + 8], ecx</span>
<span class="line">    mov si, buffer </span>
<span class="line">    call print_string</span>
<span class="line">    popa</span>
<span class="line">    ret</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A video from my YouTube channel where I implement and explain the code above in detail</p>`,24),k={href:"https://gitlab.com/x86-cpuid.org/x86-cpuid-db",target:"_blank",rel:"noopener noreferrer"},M=e("hr",null,null,-1),R=e("h2",{id:"epilogue",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#epilogue"},[e("span",null,"Epilogue")])],-1),G=e("p",null,"By understanding and using the CPUID instruction, you can make your bootloader/kernel more adaptable to a wide range of processors. Knowing how to detect the instruction's availability and retrieve crucial system informationâ€”such as CPU features, cache sizes, and supported technologiesâ€”can significantly enhance performance and compatibility.",-1),L=e("p",null,"After reading this article, you should have the tools and knowledge to start exploring the CPUID instruction and how you can use it in your own project!",-1),B=e("p",null,"Happy coding!",-1);function H(h,V){const o=l("VPCard"),i=l("router-link"),c=l("SiteInfo"),a=l("FontIcon");return f(),v("div",null,[e("h1",_,[e("a",E,[e("span",null,b(h.$frontmatter.title)+" ê´€ë ¨",1)])]),s(o,d(p({title:"Assembly > Article(s)",desc:"Article(s)",link:"/programming/asm/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e("nav",C,[e("ul",null,[e("li",null,[s(i,{to:"#what-is-the-cpuid-instruction"},{default:t(()=>[n("What is the CPUID Instruction?")]),_:1})]),e("li",null,[s(i,{to:"#prerequisites"},{default:t(()=>[n("Prerequisites")]),_:1})]),e("li",null,[s(i,{to:"#step-1-check-for-cpuid-availability"},{default:t(()=>[n("Step 1: Check for CPUID Availability")]),_:1})]),e("li",null,[s(i,{to:"#step-2-how-to-use-the-cpuid-instruction"},{default:t(()=>[n("Step 2: How to Use The CPUID Instruction")]),_:1}),e("ul",null,[e("li",null,[s(i,{to:"#get-cpu-features"},{default:t(()=>[n("Get CPU Features")]),_:1})])])]),e("li",null,[s(i,{to:"#get-cpu-vendor-string"},{default:t(()=>[n("Get CPU Vendor String")]),_:1}),e("ul",null,[e("li",null,[s(i,{to:"#step-1-the-buffer"},{default:t(()=>[n("Step 1: The Buffer")]),_:1})])])]),e("li",null,[s(i,{to:"#step-2-print-the-buffer"},{default:t(()=>[n("Step 2: Print the Buffer")]),_:1}),e("ul",null,[e("li",null,[s(i,{to:"#step-3-fill-the-buffer-and-print-it"},{default:t(()=>[n("Step 3: Fill the Buffer and Print it")]),_:1})])])]),e("li",null,[s(i,{to:"#epilogue"},{default:t(()=>[n("Epilogue")]),_:1})])])]),D,s(c,{name:"How to Retrieve System Information Using The CPUID Instruction",desc:"When developing a bootloader/kernel, understanding the underlying architecture is crucial for optimizing performance and compatibility between software and hardware. One important yet sometimes overlooked tool available to engineers for querying and ...",url:"https://freecodecamp.org/news/retrieve-system-information-using-cpuid",logo:"https://cdn.freecodecamp.org/universal/favicons/favicon.ico",preview:"https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/JMwCe3w7qKk/upload/bb94515f8210b64d35039199912a3b6c.jpeg"}),I,P,U,y,A,e("p",null,[n("By invoking this instruction, you can gather information such as the processorâ€™s model, family, internal cache sizes, and supported features like "),e("a",w,[s(a,{icon:"fa-brands fa-wikipedia-w"}),n("SIMD")]),n(" or hardware virtualization. This can help you optimize performance and dynamically enable or disable supported features.")]),S,e("p",null,[n("Hereâ€™s a picture from "),e("a",T,[s(a,{icon:"fas fa-globe"}),n("wiki.osdev.org")]),n(" that shows each bit of the EFLAGS register:")]),x,e("p",null,[n("With EAX set to 1, the CPUID will return a bitfield in EDX, which will contain the following values. Different brands may give different meaning to these (source "),e("a",F,[s(a,{icon:"fas fa-globe"}),n("https://wiki.osdev.org/CPUID")]),n(")")]),X,e("p",null,[n("More information about what information CPUID instruction can give you according to the value passed in the EAX register, can be found here: "),e("a",k,[s(a,{icon:"fa-brands fa-gitlab"}),n("https://gitlab.com/x86-cpuid.org/x86-cpuid-db")])]),s(c,{name:"x86-cpuid.org/x86-cpuid-db",desc:"A machine-readable x86 CPUID data repository and code generator.",url:"https://gitlab.com/x86-cpuid.org/x86-cpuid-db",logo:"https://gitlab.com/assets/favicon-72a2cad5025aa931d6ea56c3201d1f18e68a8cd39788c7c80d5b2b82aa5143ef.png",preview:"https://gitlab.com/uploads/-/system/project/avatar/48268467/ic_launcher.png"}),M,R,G,L,B,u(" START: ARTICLE CARD "),s(o,d(p({title:"How to Retrieve System Information Using The CPUID Instruction",desc:"When developing a bootloader/kernel, understanding the underlying architecture is crucial for optimizing performance and compatibility between software and hardware. One important yet sometimes overlooked tool available to engineers for querying and ...",link:"https://chanhi2000.github.io/bookshelf/freecodecamp.org/retrieve-system-information-using-cpuid.html",logo:"https://cdn.freecodecamp.org/universal/favicons/favicon.ico",background:"rgba(10,10,35,0.2)"})),null,16),u(" END: ARTICLE CARD ")])}const z=m(g,[["render",H],["__file","retrieve-system-information-using-cpuid.html.vue"]]),O=JSON.parse('{"path":"/freecodecamp.org/retrieve-system-information-using-cpuid.html","title":"How to Retrieve System Information Using The CPUID Instruction","lang":"en-US","frontmatter":{"lang":"en-US","title":"How to Retrieve System Information Using The CPUID Instruction","description":"Article(s) > How to Retrieve System Information Using The CPUID Instruction","icon":"fas fa-chip","category":["Assembly","Article(s)"],"tag":["blog","freecodecamp.org","asm"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > How to Retrieve System Information Using The CPUID Instruction"},{"property":"og:description","content":"How to Retrieve System Information Using The CPUID Instruction"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/freecodecamp.org/retrieve-system-information-using-cpuid.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/freecodecamp.org/retrieve-system-information-using-cpuid.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"How to Retrieve System Information Using The CPUID Instruction"}],["meta",{"property":"og:description","content":"Article(s) > How to Retrieve System Information Using The CPUID Instruction"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/JMwCe3w7qKk/upload/bb94515f8210b64d35039199912a3b6c.jpeg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/JMwCe3w7qKk/upload/bb94515f8210b64d35039199912a3b6c.jpeg"}],["meta",{"name":"twitter:image:alt","content":"How to Retrieve System Information Using The CPUID Instruction"}],["meta",{"property":"article:author","content":"Nikolaos Panagopoulos"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"freecodecamp.org"}],["meta",{"property":"article:tag","content":"asm"}],["meta",{"property":"article:published_time","content":"2024-10-03T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"How to Retrieve System Information Using The CPUID Instruction\\",\\"image\\":[\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1727637307676/82ad4bf5-3906-49a3-a12a-6cb83cc852db.png\\"],\\"datePublished\\":\\"2024-10-03T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Nikolaos Panagopoulos\\"}]}"]],"prev":"/programming/asm/articles/README.md","date":"2024-10-03T00:00:00.000Z","isOriginal":false,"author":"Nikolaos Panagopoulos","cover":"https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/JMwCe3w7qKk/upload/bb94515f8210b64d35039199912a3b6c.jpeg"},"headers":[{"level":2,"title":"What is the CPUID Instruction?","slug":"what-is-the-cpuid-instruction","link":"#what-is-the-cpuid-instruction","children":[]},{"level":2,"title":"Prerequisites","slug":"prerequisites","link":"#prerequisites","children":[]},{"level":2,"title":"Step 1: Check for CPUID Availability","slug":"step-1-check-for-cpuid-availability","link":"#step-1-check-for-cpuid-availability","children":[]},{"level":2,"title":"Step 2: How to Use The CPUID Instruction","slug":"step-2-how-to-use-the-cpuid-instruction","link":"#step-2-how-to-use-the-cpuid-instruction","children":[{"level":3,"title":"Get CPU Features","slug":"get-cpu-features","link":"#get-cpu-features","children":[]}]},{"level":2,"title":"Get CPU Vendor String","slug":"get-cpu-vendor-string","link":"#get-cpu-vendor-string","children":[{"level":3,"title":"Step 1: The Buffer","slug":"step-1-the-buffer","link":"#step-1-the-buffer","children":[]}]},{"level":2,"title":"Step 2: Print the Buffer","slug":"step-2-print-the-buffer","link":"#step-2-print-the-buffer","children":[{"level":3,"title":"Step 3: Fill the Buffer and Print it","slug":"step-3-fill-the-buffer-and-print-it","link":"#step-3-fill-the-buffer-and-print-it","children":[]}]},{"level":2,"title":"Epilogue","slug":"epilogue","link":"#epilogue","children":[]}],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":1}]},"readingTime":{"minutes":6.11,"words":1832},"filePathRelative":"freecodecamp.org/retrieve-system-information-using-cpuid.md","localizedDate":"October 3, 2024","excerpt":"\\n","copyright":{"author":"Nikolaos Panagopoulos"}}');export{z as comp,O as data};
