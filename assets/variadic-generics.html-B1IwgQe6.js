import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,b as n,t as u,e as s,n as e,g as t,d as o,a as d,f as k,r as i,o as h}from"./app-BgNevrm5.js";const m={},w={id:"frontmatter-title-관련",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-관련"},g=n("nav",{class:"table-of-contents"},[n("ul")],-1),v=n("hr",null,null,-1),b=n("blockquote",null,[n("p",null,"Available from Swift 5.9")],-1),y={href:"https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md",target:"_blank",rel:"noopener noreferrer"},P=n("code",null,"apple/swift-evolution",-1),_={href:"https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md",target:"_blank",rel:"noopener noreferrer"},T=n("code",null,"apple/swift-evolution",-1),S={href:"https://github.com/apple/swift-evolution/blob/main/proposals/0399-tuple-of-value-pack-expansion.md",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"apple/swift-evolution",-1),C=k(`<p>These proposals solve a significant problem in Swift, which is that generic functions required a specific number of type parameters. These functions could still accept variadic parameters, but they still had to use the same type ultimately.</p><p>As an example, we could have three different structs that represent different parts of our program:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">FrontEndDev</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">BackEndDev</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">FullStackDev</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In practice they would have lots more properties that make those types unique, but you get the point – three different types exist.</p><p>We could make instances of those structs like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> johnny <span class="token operator">=</span> <span class="token class-name">FrontEndDev</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Johnny Appleseed&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> jess <span class="token operator">=</span> <span class="token class-name">FrontEndDev</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Jessica Appleseed&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> kate <span class="token operator">=</span> <span class="token class-name">BackEndDev</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Kate Bell&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> kevin <span class="token operator">=</span> <span class="token class-name">BackEndDev</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Kevin Bell&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> derek <span class="token operator">=</span> <span class="token class-name">FullStackDev</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Derek Derekson&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And then when it came to actually doing work, we could pair developers together using a simple function like this one:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">pairUp1</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>firstPeople<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token operator">...</span><span class="token punctuation">,</span> secondPeople<span class="token punctuation">:</span> <span class="token class-name">U</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">assert</span><span class="token punctuation">(</span>firstPeople<span class="token punctuation">.</span>count <span class="token operator">==</span> secondPeople<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;You must provide equal numbers of people to pair.&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..&lt;</span>firstPeople<span class="token punctuation">.</span>count <span class="token punctuation">{</span></span>
<span class="line">        result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span>firstPeople<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> secondPeople<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> result</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That uses two variadic parameters to receive a group of first people and a group of second people, then returns them as an array.</p><p>We can now use that to create programmer pairs who can work on some back-end and front-end work together:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">pairUp1</span><span class="token punctuation">(</span>firstPeople<span class="token punctuation">:</span> johnny<span class="token punctuation">,</span> jess<span class="token punctuation">,</span> secondPeople<span class="token punctuation">:</span> kate<span class="token punctuation">,</span> kevin<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>So far this is old, but here’s where things get interesting: Derek is a full-stack developer, and can therefore work as either a back-end developer or a front-end developer. However, if we tried to use <code>johnny, derek</code> as the first parameter then Swift would refuse to build our code – it needs the types of all the first people and second people to be the same.</p><p>One way to fix this would be to throw away all our type information using <code>Any</code>, but parameter packs allow us to solve this much more elegantly.</p><p>The syntax might be a little intense at first, so I’m going to show you the code then try to break it down. Here it is:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">pairUp2</span><span class="token operator">&lt;</span>each <span class="token class-name">T</span><span class="token punctuation">,</span> each <span class="token class-name">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token label important">firstPeople</span><span class="token punctuation">:</span> <span class="token keyword">repeat</span> each <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token label important">secondPeople</span><span class="token punctuation">:</span> <span class="token keyword">repeat</span> each <span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token keyword">repeat</span> <span class="token punctuation">(</span>first<span class="token punctuation">:</span> each <span class="token class-name">T</span><span class="token punctuation">,</span> second<span class="token punctuation">:</span> each <span class="token class-name">U</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">repeat</span> <span class="token punctuation">(</span>each firstPeople<span class="token punctuation">,</span> each secondPeople<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There are four independent things happening there, so let’s work through them one by one:</p><ol><li><code>&lt;each T, each U&gt;</code> creates two type parameter packs, <code>T</code> and <code>U</code>.</li><li><code>repeat each T</code> is a pack expansion, which is what expands the parameter pack into actual values – it’s the equivalent of <code>T...</code>, but avoids some confusion with <code>...</code> being used as an operator.</li><li>The return type means we’re sending back tuples of paired programmers, one each from <code>T</code> and <code>U</code>.</li><li>Our <code>return</code> keyword is what does the real work: it uses a pack expansion expression to take one value from <code>T</code> and one from <code>U</code>, putting them together into the returned value.</li></ol><p>What it <em>doesn’t</em> show is that the return type automatically ensures both our <code>T</code> and <code>U</code> types have the same <em>shape</em> – they have the same number of items inside them. So, rather than using <code>assert()</code> like we had in the first function, Swift will simply issue a compiler error if we try to pass in two sets of data of different sizes.</p><p>With the new function in place, we can now pair up Derek with other developers, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">pairUp2</span><span class="token punctuation">(</span>firstPeople<span class="token punctuation">:</span> johnny<span class="token punctuation">,</span> derek<span class="token punctuation">,</span> secondPeople<span class="token punctuation">:</span> kate<span class="token punctuation">,</span> kevin<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Now, what we’ve <em>actually</em> done is implement a simple <code>zip()</code> function, which means we can write nonsense like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">pairUp2</span><span class="token punctuation">(</span>firstPeople<span class="token punctuation">:</span> johnny<span class="token punctuation">,</span> derek<span class="token punctuation">,</span> secondPeople<span class="token punctuation">:</span> kate<span class="token punctuation">,</span> <span class="token number">556</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That tries to pair Kevin with the number 556, which clearly doesn’t make any sense. This is where parameter packs really come into their own, because we could define protocols such as these:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">WritesFrontEndCode</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">protocol</span> <span class="token class-name">WritesBackEndCode</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Then add some conformances:</p><ul><li><code>FrontEndDev</code> should conform to <code>WritesFrontEndCode</code></li><li><code>BackEndDev</code> should conform to <code>WritesBackEndCode</code></li><li><code>FullStackDev</code> should conform to both <code>WritesFrontEndCode</code> and <code>WritesBackEndCode</code></li></ul><p>And now we can add constraints to our type parameter packs:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">pairUp3</span><span class="token operator">&lt;</span>each <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">WritesFrontEndCode</span><span class="token punctuation">,</span> each <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">WritesBackEndCode</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token label important">firstPeople</span><span class="token punctuation">:</span> <span class="token keyword">repeat</span> each <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token label important">secondPeople</span><span class="token punctuation">:</span> <span class="token keyword">repeat</span> each <span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token keyword">repeat</span> <span class="token punctuation">(</span>first<span class="token punctuation">:</span> each <span class="token class-name">T</span><span class="token punctuation">,</span> second<span class="token punctuation">:</span> each <span class="token class-name">U</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">repeat</span> <span class="token punctuation">(</span>each firstPeople<span class="token punctuation">,</span> each secondPeople<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That now means only sensible pairs can happen – we always get someone who can write front-end code paired with someone who can write back-end code, regardless of whether they are full-stack developers or not.</p><p>To transfer this over to something you’re more likely to be experienced with, we have a similar situation in SwiftUI. We regularly want to be able to create views with many subviews, and if we were working with a single view type such as <code>Text</code> then you could imagine something like <code>Text...</code> working great. But that <em>wouldn’t</em> work if we wanted to have some text, then an image, then a button, and more – any non-uniform layout would simply not be possible.</p><p>Trying to use <code>AnyView...</code> or similar to erase the types throws away all the type information, so before Swift 5.9 this problem was solved by creating lots of function overloads. For example, SwiftUI’s view builder has <code>buildBlock()</code> overloads that can combine two views, three views, four views, etc, all the way up to 10 views – but no further, because they need to draw a line <em>somewhere</em>.</p>`,31),U={class:"hint-container details"},E=n("summary",null,"Other Changes in Swift 5.9",-1),V={href:"https://hackingwithswift.com/files/playgrounds/swift/playground-5-8-to-5-9.playground.zip",target:"_blank",rel:"noopener noreferrer"};function D(c,A){const a=i("VPCard"),p=i("FontIcon");return h(),r("div",null,[n("h1",w,[n("a",f,[n("span",null,u(c.$frontmatter.title)+" 관련",1)])]),s(a,e(t({title:"HACKING WITH SWIFT",desc:"What's new in Swift?",link:"/hackingwithswift.com/swift/README.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),g,v,s(a,e(t({title:"Value and Type Parameter Packs | Changes in Swift 5.9",desc:"Value and Type Parameter Packs",link:"https://hackingwithswift.com/swift/5.9/variadic-generics",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),b,n("p",null,[n("a",y,[o("SE-0393 ("),s(p,{icon:"iconfont icon-github"}),P,o(")")]),o(", "),n("a",_,[o("SE-0398 ("),s(p,{icon:"iconfont icon-github"}),T,o(")")]),o(", and "),n("a",S,[o("SE-0399 ("),s(p,{icon:"iconfont icon-github"}),x]),o(") combined to form a rather dense knot of improvements to Swift that allow us to use variadic generics.")]),C,n("details",U,[E,s(a,e(t({title:"if and switch expressions | Changes in Swift 5.9",desc:"if and switch expressions",link:"/hackingwithswift.com/swift/5.9/if-switch-expressions.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),d(` 
\`\`\`component VPCard
{
  "title": "Value and Type Parameter Packs | Changes in Swift 5.9",
  "desc": "Value and Type Parameter Packs",
  "link": "/hackingwithswift.com/swift/5.9/variadic-generics.md",
  "logo": "https://hackingwithswift.com/favicon.svg",
  "background": "rgba(54,94,226,0.2)"
}
\`\`\`
`),s(a,e(t({title:"Macros | Changes in Swift 5.9",desc:"Macros",link:"/hackingwithswift.com/swift/5.9/macros.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"Noncopyable structs and enums | Changes in Swift 5.9",desc:"Noncopyable structs and enums",link:"/hackingwithswift.com/swift/5.9/noncopyable-structs-and-enums.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"consume operator to end the lifetime of a variable binding | Changes in Swift 5.9",desc:"consume operator to end the lifetime of a variable binding",link:"/hackingwithswift.com/swift/5.9/consume-operator.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"Convenience Async[Throwing]Stream.makeStream methods | Changes in Swift 5.9",desc:"Convenience Async[Throwing]Stream.makeStream methods",link:"/hackingwithswift.com/swift/5.9/convenience-asyncthrowingstream-makestream.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"Add sleep(for:) to Clock | Changes in Swift 5.9",desc:"Add sleep(for:) to Clock",link:"/hackingwithswift.com/swift/5.9/sleep-for-clock.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(a,e(t({title:"Discarding task groups | Changes in Swift 5.9",desc:"Discarding task groups",link:"/hackingwithswift.com/swift/5.9/discarding-task-groups.md",logo:"https://hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),n("p",null,[n("a",V,[s(p,{icon:"fas fa-file-zipper"}),o("Download Swift 5.9 playground")])])])])}const B=l(m,[["render",D],["__file","variadic-generics.html.vue"]]),W=JSON.parse('{"path":"/hackingwithswift.com/swift/5.9/variadic-generics.html","title":"Value and Type Parameter Packs","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Value and Type Parameter Packs","description":"Article(s) > Value and Type Parameter Packs","category":["Swift","Article(s)"],"tag":["blog","hackingwithswift.com","swift","swift-5.9"],"head":[[{"meta":null},{"property":"og:title","content":"Article(s) > Value and Type Parameter Packs"},{"property":"og:description","content":"Value and Type Parameter Packs"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/5.9/variadic-generics.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/hackingwithswift.com/swift/5.9/variadic-generics.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Value and Type Parameter Packs"}],["meta",{"property":"og:description","content":"Article(s) > Value and Type Parameter Packs"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:tag","content":"hackingwithswift.com"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swift-5.9"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Value and Type Parameter Packs\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]],"isOriginal":false},"headers":[],"git":{"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":2}]},"readingTime":{"minutes":4.58,"words":1374},"filePathRelative":"hackingwithswift.com/swift/5.9/variadic-generics.md","excerpt":"\\n"}');export{B as comp,W as data};
